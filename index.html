<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Beat Saber - –ó–∞–¥–Ω—è—è –∫–∞–º–µ—Ä–∞</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #000;
            color: white;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 3;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.2);
        }
        
        #score {
            font-size: 42px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #00ff88;
            text-shadow: 0 0 15px #00ff88;
            letter-spacing: 1px;
        }
        
        #combo {
            font-size: 26px;
            color: #ffaa00;
            margin-bottom: 15px;
            text-shadow: 0 0 10px #ffaa00;
        }
        
        #message {
            font-size: 16px;
            color: #aaa;
            margin-top: 10px;
        }
        
        #startButton {
            background: linear-gradient(45deg, #ff0080, #00ff88);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 20px;
            border-radius: 30px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 15px;
            transition: all 0.3s;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        #startButton:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.6);
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px 30px;
            border-radius: 20px;
            text-align: center;
            z-index: 3;
            backdrop-filter: blur(15px);
            width: 95%;
            max-width: 600px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 40px rgba(255, 51, 102, 0.3);
        }
        
        .hand-indicator {
            display: inline-block;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            margin: 0 8px;
            vertical-align: middle;
            box-shadow: 0 0 15px;
        }
        
        #leftHandIndicator {
            background-color: #ff3366;
            box-shadow: 0 0 15px #ff3366;
        }
        
        #rightHandIndicator {
            background-color: #33ccff;
            box-shadow: 0 0 15px #33ccff;
        }
        
        #cameraStatus {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            z-index: 3;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 12px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 20px rgba(51, 204, 255, 0.3);
        }
        
        #cameraIcon {
            font-size: 24px;
        }
        
        #cameraText {
            font-size: 16px;
            font-weight: bold;
        }
        
        #timeLeft {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 15px 25px;
            border-radius: 15px;
            z-index: 3;
            font-size: 32px;
            color: #00ff88;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(0, 255, 136, 0.3);
            box-shadow: 0 0 25px rgba(0, 255, 136, 0.4);
            font-weight: bold;
            min-width: 100px;
            text-align: center;
        }
        
        .pulse {
            animation: pulse 0.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .hidden {
            display: none !important;
        }
        
        #fps {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 8px;
            z-index: 3;
            font-size: 12px;
            color: #aaa;
        }
        
        .glow-text {
            text-shadow: 0 0 10px currentColor;
        }
        
        .neon-border {
            border: 2px solid;
            border-image: linear-gradient(45deg, #ff0080, #00ff88) 1;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }
        
        #handDebug {
            position: absolute;
            bottom: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 10px;
            z-index: 3;
            font-size: 12px;
            color: #aaa;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
</head>
<body>
    <div id="container">
        <div id="ui">
            <div id="score">0</div>
            <div id="combo">Combo: 0</div>
            <div id="message">–ó–∞–ø—É—Å–∫ —Å–∏—Å—Ç–µ–º—ã...</div>
            <button id="startButton">üöÄ –°–¢–ê–†–¢</button>
        </div>
        
        <div id="cameraStatus">
            <div id="cameraIcon">üì∑</div>
            <div id="cameraText">–ó–∞–¥–Ω—è—è –∫–∞–º–µ—Ä–∞</div>
        </div>
        
        <div id="timeLeft" class="hidden">90</div>
        
        <div id="instructions">
            <div style="margin-bottom: 15px; font-size: 18px; font-weight: bold;">
                <span class="hand-indicator" id="leftHandIndicator"></span> 
                <span style="color: #ff3366; text-shadow: 0 0 10px #ff3366;">–õ–ï–í–ê–Ø –†–£–ö–ê</span>
                <span style="margin: 0 20px; color: #aaa">|</span>
                <span class="hand-indicator" id="rightHandIndicator"></span>
                <span style="color: #33ccff; text-shadow: 0 0 10px #33ccff;">–ü–†–ê–í–ê–Ø –†–£–ö–ê</span>
            </div>
            <div style="font-size: 16px; color: #aaa; line-height: 1.5;">
                –ö—É–±—ã –ª–µ—Ç—è—Ç <span style="color: #ffaa00; font-weight: bold;">–ù–ê –í–ê–°</span>! –†–µ–∂—å—Ç–µ –∏—Ö —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–º–∏ —Ä—É–∫–∞–º–∏!
                <br>
                <span style="font-size: 14px; color: #888;">–í–∞—à–∞ –ª–∞–¥–æ–Ω—å = —Å–≤–µ—Ç–æ–≤–æ–π –º–µ—á!</span>
            </div>
        </div>
        
        <div id="fps">FPS: 0</div>
        <div id="handDebug" class="hidden"></div>
        
        <!-- –°–∫—Ä—ã—Ç—ã–π video —ç–ª–µ–º–µ–Ω—Ç -->
        <video id="inputVideo" class="hidden" autoplay playsinline></video>
        
        <canvas id="gameCanvas"></canvas>
    </div>

    <script>
        // –û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã –∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let scene, camera, renderer;
        let gameStarted = false;
        let score = 0;
        let combo = 0;
        let maxCombo = 0;
        let missedCubes = 0;
        let cubes = [];
        let sabers = { left: null, right: null };
        let saberTrails = { left: null, right: null };
        let lastCutTime = 0;
        let cubeSpawnInterval = null;
        let gameStartTime = 0;
        let timeLeft = 90;
        let timeInterval = null;
        let currentStream = null;
        let videoElement = document.getElementById('inputVideo');
        let videoTexture = null;
        let frameCount = 0;
        let lastFpsTime = 0;
        let fps = 0;
        
        // –≠–ª–µ–º–µ–Ω—Ç—ã DOM
        const scoreElement = document.getElementById('score');
        const comboElement = document.getElementById('combo');
        const messageElement = document.getElementById('message');
        const startButton = document.getElementById('startButton');
        const leftHandIndicator = document.getElementById('leftHandIndicator');
        const rightHandIndicator = document.getElementById('rightHandIndicator');
        const timeLeftElement = document.getElementById('timeLeft');
        const cameraStatus = document.getElementById('cameraStatus');
        const fpsElement = document.getElementById('fps');
        const handDebugElement = document.getElementById('handDebug');
        
        // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∏–≥—Ä—ã
        const CONFIG = {
            // –ö–∞–º–µ—Ä–∞ –∏ —Ä—É–∫–∏
            CAMERA_FOV: 75,
            CAMERA_HEIGHT: 1.7,
            HAND_SCALE: 2.0,
            
            // –ò–≥—Ä–æ–≤–æ–π –º–∏—Ä
            ARENA_WIDTH: 8,
            ARENA_DEPTH: 20,
            ARENA_HEIGHT: 5,
            
            // –ö—É–±—ã
            CUBE_SPAWN_RATE: 700,
            CUBE_SPEED_MIN: 0.12,
            CUBE_SPEED_MAX: 0.18,
            CUBE_LANES: [-2, -0.67, 0.67, 2], // –ö–∞–∫ –≤ Beat Saber
            CUBE_START_Z: 15,
            CUBE_END_Z: 2,
            
            // –°–∞–±–ª–∏
            SABER_LENGTH: 1.5,
            SABER_WIDTH: 0.06,
            TRAIL_LENGTH: 20,
            
            // –ò–≥—Ä–∞
            GAME_TIME: 90,
            MISS_LIMIT: 20,
            COMBO_TIMEOUT: 2000
        };
        
        // –¶–≤–µ—Ç–∞ –Ω–µ–æ–Ω–æ–≤–æ–π —Ç–µ–º—ã
        const COLORS = {
            NEON_PINK: 0xff00ff,
            NEON_BLUE: 0x00ffff,
            NEON_GREEN: 0x00ff88,
            NEON_RED: 0xff3366,
            NEON_CYAN: 0x33ccff,
            NEON_PURPLE: 0x9933ff,
            NEON_YELLOW: 0xffff00,
            DARK_BG: 0x000011,
            LASER_WALL: 0x00aaff,
            GRID: 0x3366ff
        };
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Three.js
        function initThreeJS() {
            // –°–æ–∑–¥–∞–µ–º —Å—Ü–µ–Ω—É —Å –Ω–µ–æ–Ω–æ–≤–æ–π –∞—Ç–º–æ—Å—Ñ–µ—Ä–æ–π
            scene = new THREE.Scene();
            scene.background = new THREE.Color(COLORS.DARK_BG);
            scene.fog = new THREE.Fog(COLORS.DARK_BG, 5, 25);
            
            // –ö–∞–º–µ—Ä–∞ –æ—Ç –ø–µ—Ä–≤–æ–≥–æ –ª–∏—Ü–∞
            camera = new THREE.PerspectiveCamera(
                CONFIG.CAMERA_FOV,
                window.innerWidth / window.innerHeight,
                0.1,
                100
            );
            camera.position.set(0, CONFIG.CAMERA_HEIGHT, 0);
            camera.lookAt(0, CONFIG.CAMERA_HEIGHT, 10);
            
            // –†–µ–Ω–¥–µ—Ä–µ—Ä —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º–∏ —ç—Ñ—Ñ–µ–∫—Ç–∞–º–∏
            const canvas = document.getElementById('gameCanvas');
            renderer = new THREE.WebGLRenderer({
                canvas,
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            
            // –°–æ–∑–¥–∞–µ–º –Ω–µ–æ–Ω–æ–≤—É—é –∞—Ä–µ–Ω—É
            createNeonArena();
            
            // –°–æ–∑–¥–∞–µ–º —Å–∞–±–ª–∏
            createSabers();
            
            // –°–æ–∑–¥–∞–µ–º –ª–∞–∑–µ—Ä–Ω—ã–µ —Å—Ç–µ–Ω—ã –∏ —ç—Ñ—Ñ–µ–∫—Ç—ã
            createLaserWalls();
            createParticleField();
            createNeonGrid();
            
            messageElement.textContent = "–°–æ–∑–¥–∞–Ω–∏–µ –∏–≥—Ä–æ–≤–æ–≥–æ –º–∏—Ä–∞...";
            
            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞
            window.addEventListener('resize', onWindowResize);
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –Ω–µ–æ–Ω–æ–≤–æ–π –∞—Ä–µ–Ω—ã –∫–∞–∫ –≤ Beat Saber
        function createNeonArena() {
            // –ü–æ–ª –∞—Ä–µ–Ω—ã —Å –Ω–µ–æ–Ω–æ–≤—ã–º —Å–≤–µ—á–µ–Ω–∏–µ–º
            const floorGeometry = new THREE.PlaneGeometry(CONFIG.ARENA_WIDTH, CONFIG.ARENA_DEPTH);
            const floorMaterial = new THREE.MeshPhongMaterial({
                color: 0x111133,
                emissive: 0x222244,
                emissiveIntensity: 0.3,
                shininess: 100,
                transparent: true,
                opacity: 0.9
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -0.5;
            floor.position.z = CONFIG.ARENA_DEPTH / 2;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // –ù–µ–æ–Ω–æ–≤—ã–µ –ª–∏–Ω–∏–∏ –Ω–∞ –ø–æ–ª—É
            const lineMaterial = new THREE.LineBasicMaterial({
                color: COLORS.GRID,
                transparent: true,
                opacity: 0.4,
                linewidth: 2
            });
            
            // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏
            for (let z = 0; z <= CONFIG.ARENA_DEPTH; z += 2) {
                const points = [
                    new THREE.Vector3(-CONFIG.ARENA_WIDTH/2, 0.1, z),
                    new THREE.Vector3(CONFIG.ARENA_WIDTH/2, 0.1, z)
                ];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, lineMaterial);
                scene.add(line);
            }
            
            // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏ (–¥–æ—Ä–æ–∂–∫–∏)
            CONFIG.CUBE_LANES.forEach(x => {
                const points = [
                    new THREE.Vector3(x, 0.1, 0),
                    new THREE.Vector3(x, 0.1, CONFIG.ARENA_DEPTH)
                ];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, lineMaterial);
                scene.add(line);
            });
            
            // –ë–æ–∫–æ–≤—ã–µ –ª–∞–∑–µ—Ä–Ω—ã–µ —Å—Ç–µ–Ω—ã
            const wallMaterial = new THREE.MeshBasicMaterial({
                color: COLORS.LASER_WALL,
                transparent: true,
                opacity: 0.1,
                side: THREE.DoubleSide
            });
            
            const leftWall = new THREE.Mesh(
                new THREE.PlaneGeometry(CONFIG.ARENA_DEPTH, CONFIG.ARENA_HEIGHT),
                wallMaterial
            );
            leftWall.position.x = -CONFIG.ARENA_WIDTH/2 - 0.5;
            leftWall.position.z = CONFIG.ARENA_DEPTH/2;
            leftWall.position.y = CONFIG.ARENA_HEIGHT/2 - 0.5;
            leftWall.rotation.y = Math.PI/2;
            scene.add(leftWall);
            
            const rightWall = new THREE.Mesh(
                new THREE.PlaneGeometry(CONFIG.ARENA_DEPTH, CONFIG.ARENA_HEIGHT),
                wallMaterial
            );
            rightWall.position.x = CONFIG.ARENA_WIDTH/2 + 0.5;
            rightWall.position.z = CONFIG.ARENA_DEPTH/2;
            rightWall.position.y = CONFIG.ARENA_HEIGHT/2 - 0.5;
            rightWall.rotation.y = -Math.PI/2;
            scene.add(rightWall);
            
            // –ó–∞–¥–Ω—è—è –ª–∞–∑–µ—Ä–Ω–∞—è —Å—Ç–µ–Ω–∞
            const backWall = new THREE.Mesh(
                new THREE.PlaneGeometry(CONFIG.ARENA_WIDTH, CONFIG.ARENA_HEIGHT),
                wallMaterial
            );
            backWall.position.z = CONFIG.ARENA_DEPTH + 1;
            backWall.position.y = CONFIG.ARENA_HEIGHT/2 - 0.5;
            scene.add(backWall);
            
            // –û—Å–≤–µ—â–µ–Ω–∏–µ
            const ambientLight = new THREE.AmbientLight(0x333366, 0.4);
            scene.add(ambientLight);
            
            // –ù–µ–æ–Ω–æ–≤—ã–µ –ø—Ä–æ–∂–µ–∫—Ç–æ—Ä—ã
            const spotLight1 = new THREE.SpotLight(COLORS.NEON_BLUE, 0.8, 30, Math.PI/4, 0.5, 1);
            spotLight1.position.set(-3, 5, 5);
            spotLight1.target.position.set(0, 0, 10);
            spotLight1.castShadow = true;
            scene.add(spotLight1);
            scene.add(spotLight1.target);
            
            const spotLight2 = new THREE.SpotLight(COLORS.NEON_PINK, 0.8, 30, Math.PI/4, 0.5, 1);
            spotLight2.position.set(3, 5, 5);
            spotLight2.target.position.set(0, 0, 10);
            spotLight2.castShadow = true;
            scene.add(spotLight2);
            scene.add(spotLight2.target);
            
            // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –∞—Ä–µ–Ω—ã
            const arenaLight = new THREE.PointLight(COLORS.NEON_GREEN, 0.5, 20);
            arenaLight.position.set(0, 2, 10);
            scene.add(arenaLight);
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —Å–∞–±–µ–ª—å (—Å–≤–µ—Ç–æ–≤—ã—Ö –º–µ—á–µ–π)
        function createSabers() {
            // –õ–µ–≤–∞—è —Å–∞–±–ª—è (—Ä–æ–∑–æ–≤–∞—è)
            createSaber('left', COLORS.NEON_PINK);
            // –ü—Ä–∞–≤–∞—è —Å–∞–±–ª—è (–≥–æ–ª—É–±–∞—è)
            createSaber('right', COLORS.NEON_CYAN);
        }
        
        function createSaber(side, color) {
            const group = new THREE.Group();
            
            // –°–æ–∑–¥–∞–µ–º –º–µ—á –∏–∑ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —á–∞—Å—Ç–µ–π –¥–ª—è –ª—É—á—à–µ–≥–æ —Å–≤–µ—á–µ–Ω–∏—è
            const bladeLength = CONFIG.SABER_LENGTH;
            const bladeWidth = CONFIG.SABER_WIDTH;
            
            // –Ø–¥—Ä–æ –º–µ—á–∞ (—è—Ä–∫–∞—è —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è —á–∞—Å—Ç—å)
            const coreGeometry = new THREE.CylinderGeometry(
                bladeWidth * 0.3,
                bladeWidth * 0.3,
                bladeLength,
                8
            );
            const coreMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 1.0,
                blending: THREE.AdditiveBlending
            });
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            core.position.y = bladeLength / 2;
            group.add(core);
            
            // –û—Å–Ω–æ–≤–Ω–æ–µ –ª–µ–∑–≤–∏–µ
            const bladeGeometry = new THREE.CylinderGeometry(
                bladeWidth,
                bladeWidth,
                bladeLength,
                16
            );
            const bladeMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending
            });
            const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
            blade.position.y = bladeLength / 2;
            group.add(blade);
            
            // –í–Ω–µ—à–Ω–µ–µ —Å–≤–µ—á–µ–Ω–∏–µ
            const glowGeometry = new THREE.CylinderGeometry(
                bladeWidth * 2,
                bladeWidth * 2,
                bladeLength + 0.2,
                16
            );
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.2,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.y = bladeLength / 2;
            group.add(glow);
            
            // –†—É–∫–æ—è—Ç—å
            const handleGeometry = new THREE.CylinderGeometry(
                bladeWidth * 1.5,
                bladeWidth * 1.5,
                bladeLength * 0.3,
                8
            );
            const handleMaterial = new THREE.MeshPhongMaterial({
                color: 0x333333,
                emissive: 0x111111,
                emissiveIntensity: 0.5,
                shininess: 100
            });
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.position.y = -bladeLength * 0.15;
            group.add(handle);
            
            // –î–æ–±–∞–≤–ª—è–µ–º –≤ —Å—Ü–µ–Ω—É
            scene.add(group);
            
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Å—ã–ª–∫–∏
            sabers[side] = {
                group: group,
                blade: blade,
                core: core,
                glow: glow,
                handle: handle,
                position: new THREE.Vector3(),
                velocity: new THREE.Vector3(),
                lastPosition: new THREE.Vector3(),
                isDetected: false,
                isCutting: false,
                color: color
            };
            
            // –°–æ–∑–¥–∞–µ–º —Å–ª–µ–¥ –¥–ª—è —Å–∞–±–ª–∏
            createSaberTrail(side, color);
            
            // –ò–∑–Ω–∞—á–∞–ª—å–Ω–æ —Å–∫—Ä—ã–≤–∞–µ–º
            group.visible = false;
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —Å–ª–µ–¥–∞ –¥–ª—è —Å–∞–±–ª–∏
        function createSaberTrail(side, color) {
            const trailGeometry = new THREE.BufferGeometry();
            const trailMaterial = new THREE.LineBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.8,
                linewidth: 3,
                blending: THREE.AdditiveBlending
            });
            
            const trail = new THREE.Line(trailGeometry, trailMaterial);
            scene.add(trail);
            
            saberTrails[side] = {
                line: trail,
                points: [],
                maxPoints: CONFIG.TRAIL_LENGTH,
                colors: []
            };
            
            trail.visible = false;
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–ª–µ–¥–∞ —Å–∞–±–ª–∏
        function updateSaberTrail(side, position) {
            const trail = saberTrails[side];
            if (!trail || !sabers[side].isDetected) return;
            
            // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—É—é —Ç–æ—á–∫—É
            trail.points.unshift(position.clone());
            trail.colors.unshift(sabers[side].color);
            
            // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ—á–µ–∫
            if (trail.points.length > trail.maxPoints) {
                trail.points.pop();
                trail.colors.pop();
            }
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –≥–µ–æ–º–µ—Ç—Ä–∏—é —Å –≥—Ä–∞–¥–∏–µ–Ω—Ç–æ–º —Ü–≤–µ—Ç–∞
            if (trail.points.length > 1) {
                const positions = new Float32Array(trail.points.length * 3);
                const colors = new Float32Array(trail.colors.length * 3);
                
                for (let i = 0; i < trail.points.length; i++) {
                    positions[i * 3] = trail.points[i].x;
                    positions[i * 3 + 1] = trail.points[i].y;
                    positions[i * 3 + 2] = trail.points[i].z;
                    
                    const color = new THREE.Color(trail.colors[i]);
                    const alpha = 1 - (i / trail.points.length);
                    color.multiplyScalar(alpha);
                    
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                }
                
                trail.line.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                trail.line.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                trail.line.geometry.attributes.position.needsUpdate = true;
                trail.line.geometry.attributes.color.needsUpdate = true;
                trail.line.visible = true;
            }
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –ª–∞–∑–µ—Ä–Ω—ã—Ö —Å—Ç–µ–Ω
        function createLaserWalls() {
            const laserMaterial = new THREE.MeshBasicMaterial({
                color: COLORS.LASER_WALL,
                transparent: true,
                opacity: 0.15,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });
            
            // –õ–∞–∑–µ—Ä–Ω—ã–µ –ø–æ–ª–æ—Å—ã –Ω–∞ —Å—Ç–µ–Ω–∞—Ö
            for (let z = 2; z < CONFIG.ARENA_DEPTH; z += 3) {
                const laserGeometry = new THREE.PlaneGeometry(CONFIG.ARENA_WIDTH, 0.1);
                const laser = new THREE.Mesh(laserGeometry, laserMaterial);
                laser.position.z = z;
                laser.position.y = 1.5;
                laser.rotation.y = Math.PI;
                scene.add(laser);
            }
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –Ω–µ–æ–Ω–æ–≤–æ–π —Å–µ—Ç–∫–∏
        function createNeonGrid() {
            const gridMaterial = new THREE.LineBasicMaterial({
                color: COLORS.GRID,
                transparent: true,
                opacity: 0.1,
                linewidth: 1
            });
            
            // –°–µ—Ç–∫–∞ –Ω–∞ –∑–∞–¥–Ω–µ–º –ø–ª–∞–Ω–µ
            const gridSize = 20;
            const gridDivisions = 20;
            const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, COLORS.GRID, COLORS.GRID);
            gridHelper.material.opacity = 0.05;
            gridHelper.material.transparent = true;
            gridHelper.position.z = 10;
            scene.add(gridHelper);
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–ª—è —á–∞—Å—Ç–∏—Ü
        function createParticleField() {
            const particleCount = 500;
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const colors = [];
            
            for (let i = 0; i < particleCount; i++) {
                const x = (Math.random() - 0.5) * 50;
                const y = (Math.random() - 0.5) * 20;
                const z = Math.random() * 50;
                
                vertices.push(x, y, z);
                
                const color = new THREE.Color();
                color.setHSL(Math.random() * 0.3 + 0.5, 0.8, 0.5);
                colors.push(color.r, color.g, color.b);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });
            
            const particles = new THREE.Points(geometry, material);
            scene.add(particles);
            
            // –ê–Ω–∏–º–∞—Ü–∏—è —á–∞—Å—Ç–∏—Ü
            function animateParticles() {
                const positions = particles.geometry.attributes.position.array;
                
                for (let i = 0; i < particleCount * 3; i += 3) {
                    positions[i + 2] -= 0.05;
                    if (positions[i + 2] < -10) {
                        positions[i + 2] = 50;
                    }
                }
                
                particles.geometry.attributes.position.needsUpdate = true;
                
                if (gameStarted) {
                    requestAnimationFrame(animateParticles);
                }
            }
            
            animateParticles();
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –∫—É–±–∞
        function createCube() {
            const isLeft = Math.random() > 0.5;
            const color = isLeft ? COLORS.NEON_RED : COLORS.NEON_CYAN;
            const targetHand = isLeft ? 'left' : 'right';
            
            const lanePositions = isLeft 
                ? CONFIG.CUBE_LANES.filter((_, i) => i < 2)
                : CONFIG.CUBE_LANES.filter((_, i) => i >= 2);
            
            const lane = lanePositions[Math.floor(Math.random() * lanePositions.length)];
            
            const geometry = new THREE.BoxGeometry(0.9, 0.9, 0.9);
            const material = new THREE.MeshPhongMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.8,
                shininess: 100,
                transparent: true,
                opacity: 0.95
            });
            
            const cube = new THREE.Mesh(geometry, material);
            cube.castShadow = true;
            cube.receiveShadow = true;
            
            cube.position.x = lane;
            cube.position.y = 1.5;
            cube.position.z = CONFIG.CUBE_START_Z;
            
            // –î–æ–±–∞–≤–ª—è–µ–º —Å—Ç—Ä–µ–ª–∫—É –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è
            const arrowGeometry = new THREE.ConeGeometry(0.2, 0.4, 4);
            const arrowMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                emissive: 0xffffff,
                emissiveIntensity: 0.5
            });
            const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
            arrow.rotation.x = Math.PI;
            arrow.position.z = -0.45;
            cube.add(arrow);
            
            // –°–≤–µ—á–µ–Ω–∏–µ –∫—É–±–∞
            const glowGeometry = new THREE.BoxGeometry(1.1, 1.1, 1.1);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.2,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            cube.add(glow);
            
            cube.userData = {
                targetHand: targetHand,
                color: color,
                speed: CONFIG.CUBE_SPEED_MIN + Math.random() * (CONFIG.CUBE_SPEED_MAX - CONFIG.CUBE_SPEED_MIN),
                direction: new THREE.Vector3(0, 0, -1),
                spawnTime: Date.now(),
                isActive: true,
                lane: lane
            };
            
            scene.add(cube);
            cubes.push(cube);
            
            return cube;
        }
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–∞–º–µ—Ä—ã (–ü–ï–†–ï–î–ù–Ø–Ø –∫–∞–º–µ—Ä–∞ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —Ä—É–∫)
        async function initCamera() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                
                let frontCamera = null;
                // –ò—â–µ–º –ø–µ—Ä–µ–¥–Ω—é—é –∫–∞–º–µ—Ä—É (–æ–±—ã—á–Ω–æ "user" –∏–ª–∏ "front")
                for (const device of videoDevices) {
                    if (device.label.toLowerCase().includes('front') || 
                        device.label.toLowerCase().includes('face') ||
                        device.label.toLowerCase().includes('user')) {
                        frontCamera = device;
                        break;
                    }
                }
                
                // –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏, –±–µ—Ä–µ–º –ø–µ—Ä–≤—É—é –∫–∞–º–µ—Ä—É
                if (!frontCamera && videoDevices.length > 0) {
                    frontCamera = videoDevices[0];
                }
                
                const constraints = {
                    video: {
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        frameRate: { ideal: 60 },
                        facingMode: frontCamera ? { exact: frontCamera.deviceId } : 'user'
                    },
                    audio: false
                };
                
                currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                videoElement.srcObject = currentStream;
                
                await new Promise(resolve => {
                    videoElement.onloadedmetadata = () => {
                        videoElement.play();
                        resolve();
                    };
                });
                
                // –°–æ–∑–¥–∞–µ–º —Ç–µ–∫—Å—Ç—É—Ä—É –∏–∑ –≤–∏–¥–µ–æ –¥–ª—è –≤–æ–∑–º–æ–∂–Ω–æ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
                videoTexture = new THREE.VideoTexture(videoElement);
                videoTexture.minFilter = THREE.LinearFilter;
                videoTexture.magFilter = THREE.LinearFilter;
                videoTexture.format = THREE.RGBFormat;
                
                cameraStatus.querySelector('#cameraIcon').textContent = '‚úÖ';
                cameraStatus.querySelector('#cameraText').textContent = '–ö–∞–º–µ—Ä–∞ –≥–æ—Ç–æ–≤–∞';
                cameraStatus.style.borderColor = '#00ff88';
                
                return true;
                
            } catch (error) {
                console.error("Camera error:", error);
                cameraStatus.querySelector('#cameraIcon').textContent = '‚ùå';
                cameraStatus.querySelector('#cameraText').textContent = '–ù–µ—Ç –∫–∞–º–µ—Ä—ã';
                cameraStatus.style.borderColor = '#ff3366';
                messageElement.textContent = "–¢—Ä–µ–±—É–µ—Ç—Å—è –∫–∞–º–µ—Ä–∞ –¥–ª—è –∏–≥—Ä—ã!";
                return false;
            }
        }
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —Ä—É–∫
        async function initHandTracking() {
            messageElement.textContent = "–ó–∞–ø—É—Å–∫ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —Ä—É–∫...";
            
            // –°–æ–∑–¥–∞–µ–º –ø—Ä–æ—Å—Ç–æ–π –¥–µ—Ç–µ–∫—Ç–æ—Ä —Ä—É–∫ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ü–≤–µ—Ç–æ–≤–æ–≥–æ —Ç—Ä–µ–∫–∏–Ω–≥–∞
            // –í —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–æ–µ–∫—Ç–µ –∑–¥–µ—Å—å –±—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª—Å—è MediaPipe –∏–ª–∏ –∞–Ω–∞–ª–æ–≥–∏—á–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞
            
            // –ó–∞–ø—É—Å–∫–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É –≤–∏–¥–µ–æ
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 640;
            canvas.height = 480;
            
            let leftHandDetected = false;
            let rightHandDetected = false;
            
            function processVideoFrame() {
                if (!gameStarted || !videoElement.videoWidth) return;
                
                ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                // –ü—Ä–æ—Å—Ç–∞—è –¥–µ—Ç–µ–∫—Ü–∏—è –¥–≤–∏–∂–µ–Ω–∏—è (–¥–ª—è –¥–µ–º–æ)
                // –í —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–æ–µ–∫—Ç–µ –∑–¥–µ—Å—å –±—ã –±—ã–ª–∞ –Ω–µ–π—Ä–æ—Å–µ—Ç—å
                
                // –°–∏–º—É–ª–∏—Ä—É–µ–º –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ —Ä—É–∫ –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏
                const currentTime = Date.now();
                leftHandDetected = (currentTime % 2000) < 1900;
                rightHandDetected = (currentTime % 2000) < 1900;
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏–∏ —Å–∞–±–µ–ª—å –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–∏–º—É–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
                updateSaberPosition('left', leftHandDetected, currentTime);
                updateSaberPosition('right', rightHandDetected, currentTime);
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã
                leftHandIndicator.style.backgroundColor = leftHandDetected ? '#ff3366' : '#555';
                rightHandIndicator.style.backgroundColor = rightHandDetected ? '#33ccff' : '#555';
                
                requestAnimationFrame(processVideoFrame);
            }
            
            function updateSaberPosition(side, detected, time) {
                const saber = sabers[side];
                
                if (detected) {
                    // –°–∏–º—É–ª–∏—Ä—É–µ–º –¥–≤–∏–∂–µ–Ω–∏–µ —Ä—É–∫
                    const t = time * 0.001;
                    const offset = side === 'left' ? 0 : Math.PI;
                    
                    // –ü–æ–∑–∏—Ü–∏—è —Å–∏–º—É–ª–∏—Ä–æ–≤–∞–Ω–Ω–æ–π —Ä—É–∫–∏
                    const x = Math.sin(t * 2 + offset) * 1.5;
                    const y = 1.5 + Math.cos(t * 1.5 + offset) * 0.5;
                    const z = 2 + Math.sin(t * 3 + offset) * 0.3;
                    
                    const newPosition = new THREE.Vector3(x, y, z);
                    
                    // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å
                    if (saber.lastPosition.x !== 0 || saber.lastPosition.y !== 0 || saber.lastPosition.z !== 0) {
                        saber.velocity.subVectors(newPosition, saber.lastPosition);
                    }
                    saber.lastPosition.copy(saber.position);
                    saber.position.copy(newPosition);
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –∏ –≤—Ä–∞—â–µ–Ω–∏–µ
                    saber.group.position.copy(saber.position);
                    
                    // –í—Ä–∞—â–∞–µ–º –º–µ—á –≤ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ –¥–≤–∏–∂–µ–Ω–∏—è
                    if (saber.velocity.length() > 0.01) {
                        const targetPos = saber.position.clone().add(saber.velocity.normalize());
                        saber.group.lookAt(targetPos);
                    } else {
                        saber.group.rotation.set(0, 0, 0);
                    }
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º —Å–ª–µ–¥
                    const trailPos = saber.position.clone();
                    trailPos.y += 0.5;
                    updateSaberTrail(side, trailPos);
                    
                    saber.isDetected = true;
                    saber.group.visible = true;
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–ª–∏–∑–∏–∏
                    checkSaberCollisions(side);
                    
                } else {
                    saber.isDetected = false;
                    saber.group.visible = false;
                    saberTrails[side].line.visible = false;
                }
            }
            
            // –ó–∞–ø—É—Å–∫–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É
            setTimeout(processVideoFrame, 1000);
            messageElement.textContent = "–û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ —Ä—É–∫ –∞–∫—Ç–∏–≤–Ω–æ!";
            
            // –î–ª—è –¥–µ–º–æ: –¥–æ–±–∞–≤–ª—è–µ–º —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º—ã—à—å—é/—Ç–∞—á–µ–º
            initMouseControls();
            
            return true;
        }
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –º—ã—à—å—é/—Ç–∞—á–µ–º –¥–ª—è –¥–µ–º–æ
        function initMouseControls() {
            const mousePos = { x: 0, y: 0 };
            const touchActive = { left: false, right: false };
            
            // –ú—ã—à—å –¥–ª—è –ª–µ–≤–æ–π —Ä—É–∫–∏
            document.addEventListener('mousemove', (e) => {
                mousePos.x = (e.clientX / window.innerWidth) * 2 - 1;
                mousePos.y = -(e.clientY / window.innerHeight) * 2 + 1;
                
                if (gameStarted) {
                    const x = mousePos.x * 3;
                    const y = mousePos.y * 2 + 2;
                    const z = 2;
                    
                    updateSaberFromInput('left', x, y, z);
                    leftHandIndicator.style.backgroundColor = '#ff3366';
                }
            });
            
            document.addEventListener('mousedown', () => {
                if (gameStarted) {
                    touchActive.left = true;
                    checkSaberCollisions('left');
                }
            });
            
            document.addEventListener('mouseup', () => {
                touchActive.left = false;
            });
            
            // –¢–∞—á –¥–ª—è –ø—Ä–∞–≤–æ–π —Ä—É–∫–∏ (–º–æ–±–∏–ª—å–Ω—ã–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞)
            document.addEventListener('touchstart', (e) => {
                if (!gameStarted) return;
                
                e.preventDefault();
                touchActive.right = true;
                
                const touch = e.touches[0];
                const x = (touch.clientX / window.innerWidth) * 2 - 1;
                const y = -(touch.clientY / window.innerHeight) * 2 + 1;
                
                updateSaberFromInput('right', x * 3, y * 2 + 2, 2);
                rightHandIndicator.style.backgroundColor = '#33ccff';
                checkSaberCollisions('right');
            });
            
            document.addEventListener('touchmove', (e) => {
                if (!gameStarted || !touchActive.right) return;
                
                e.preventDefault();
                const touch = e.touches[0];
                const x = (touch.clientX / window.innerWidth) * 2 - 1;
                const y = -(touch.clientY / window.innerHeight) * 2 + 1;
                
                updateSaberFromInput('right', x * 3, y * 2 + 2, 2);
                checkSaberCollisions('right');
            });
            
            document.addEventListener('touchend', () => {
                touchActive.right = false;
            });
        }
        
        function updateSaberFromInput(side, x, y, z) {
            const saber = sabers[side];
            const newPosition = new THREE.Vector3(x, y, z);
            
            if (saber.lastPosition.x !== 0 || saber.lastPosition.y !== 0 || saber.lastPosition.z !== 0) {
                saber.velocity.subVectors(newPosition, saber.lastPosition);
            }
            saber.lastPosition.copy(saber.position);
            saber.position.copy(newPosition);
            
            saber.group.position.copy(saber.position);
            
            if (saber.velocity.length() > 0.01) {
                const targetPos = saber.position.clone().add(saber.velocity.normalize());
                saber.group.lookAt(targetPos);
            }
            
            updateSaberTrail(side, saber.position.clone().add(new THREE.Vector3(0, 0.5, 0)));
            
            saber.isDetected = true;
            saber.group.visible = true;
        }
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π —Å–∞–±–ª–∏ —Å –∫—É–±–∞–º–∏
        function checkSaberCollisions(side) {
            const saber = sabers[side];
            if (!saber || !saber.isDetected) return;
            
            const saberSphere = new THREE.Sphere(saber.position, 0.8);
            
            for (let i = cubes.length - 1; i >= 0; i--) {
                const cube = cubes[i];
                if (!cube.userData.isActive) continue;
                
                if (cube.userData.targetHand !== side) continue;
                
                const cubeSphere = new THREE.Sphere(cube.position, 0.6);
                
                if (saberSphere.intersectsSphere(cubeSphere)) {
                    const saberSpeed = saber.velocity.length();
                    
                    if (saberSpeed > 0.05) {
                        cutCube(cube, side, saberSpeed);
                        cubes.splice(i, 1);
                        saber.isCutting = true;
                        
                        // –£—Å–∏–ª–∏–≤–∞–µ–º —Å–≤–µ—á–µ–Ω–∏–µ –ø—Ä–∏ —É–¥–∞—Ä–µ
                        saber.core.material.opacity = 1.5;
                        saber.blade.material.opacity = 1.0;
                        saber.glow.material.opacity = 0.4;
                        
                        setTimeout(() => {
                            if (saber.core) {
                                saber.core.material.opacity = 1.0;
                                saber.blade.material.opacity = 0.7;
                                saber.glow.material.opacity = 0.2;
                            }
                            saber.isCutting = false;
                        }, 100);
                    }
                }
            }
        }
        
        // –†–∞–∑—Ä–µ–∑–∞–Ω–∏–µ –∫—É–±–∞
        function cutCube(cube, side, speed) {
            cube.userData.isActive = false;
            lastCutTime = Date.now();
            
            combo++;
            const points = Math.floor(15 * combo * Math.min(speed * 20, 3));
            score += points;
            
            if (combo > maxCombo) maxCombo = combo;
            
            scoreElement.textContent = score;
            comboElement.textContent = `Combo: ${combo} (Max: ${maxCombo})`;
            comboElement.style.color = combo >= 10 ? '#ffaa00' : '#00ff88';
            comboElement.style.textShadow = combo >= 10 ? '0 0 15px #ffaa00' : '0 0 10px #00ff88';
            
            // –°–æ–∑–¥–∞–µ–º —ç—Ñ—Ñ–µ–∫—Ç –≤–∑—Ä—ã–≤–∞
            createCubeExplosion(cube.position, cube.userData.color, speed);
            
            // –í–∏–±—Ä–∞—Ü–∏—è
            if (navigator.vibrate) navigator.vibrate(50);
            
            // –£–¥–∞–ª—è–µ–º –∫—É–±
            scene.remove(cube);
        }
        
        // –≠—Ñ—Ñ–µ–∫—Ç –≤–∑—Ä—ã–≤–∞ –∫—É–±–∞
        function createCubeExplosion(position, color, speed) {
            const particleCount = Math.floor(30 * speed);
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 0.8;
                const x = Math.cos(angle) * radius;
                const y = (Math.random() - 0.5) * 1;
                const z = Math.sin(angle) * radius;
                vertices.push(x, y, z);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            
            const material = new THREE.PointsMaterial({
                color: color,
                size: 0.1,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending
            });
            
            const particles = new THREE.Points(geometry, material);
            particles.position.copy(position);
            scene.add(particles);
            
            const particleData = [];
            for (let i = 0; i < particleCount; i++) {
                particleData.push({
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.6,
                        (Math.random() - 0.5) * 0.6,
                        (Math.random() - 0.5) * 0.6
                    ),
                    life: 1.0
                });
            }
            
            function animateParticles() {
                let allDead = true;
                const positions = particles.geometry.attributes.position.array;
                
                for (let i = 0; i < particleCount; i++) {
                    const data = particleData[i];
                    if (data.life > 0) {
                        allDead = false;
                        data.life -= 0.03;
                        
                        positions[i * 3] += data.velocity.x;
                        positions[i * 3 + 1] += data.velocity.y;
                        positions[i * 3 + 2] += data.velocity.z;
                        
                        data.velocity.y -= 0.02;
                    }
                }
                
                particles.geometry.attributes.position.needsUpdate = true;
                material.opacity -= 0.04;
                material.size -= 0.003;
                
                if (allDead || material.opacity <= 0) {
                    scene.remove(particles);
                    return;
                }
                
                requestAnimationFrame(animateParticles);
            }
            
            animateParticles();
        }
        
        // –ó–∞–ø—É—Å–∫ –∏–≥—Ä—ã
        function startGame() {
            if (gameStarted) {
                stopGame();
                return;
            }
            
            gameStarted = true;
            gameStartTime = Date.now();
            score = 0;
            combo = 0;
            maxCombo = 0;
            missedCubes = 0;
            timeLeft = CONFIG.GAME_TIME;
            
            // –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ –∫—É–±—ã
            cubes.forEach(cube => scene.remove(cube));
            cubes = [];
            
            // –û–±–Ω–æ–≤–ª—è–µ–º UI
            scoreElement.textContent = "0";
            comboElement.textContent = "Combo: 0 (Max: 0)";
            comboElement.style.color = '#00ff88';
            comboElement.style.textShadow = '0 0 10px #00ff88';
            messageElement.textContent = "–ò–≥—Ä–∞ –Ω–∞—á–∞–ª–∞—Å—å! –†–µ–∂—å—Ç–µ –∫—É–±—ã!";
            startButton.textContent = "‚è∏Ô∏è –°–¢–û–ü";
            timeLeftElement.textContent = timeLeft;
            timeLeftElement.classList.remove('hidden');
            
            // –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–∞–π–º–µ—Ä
            if (timeInterval) clearInterval(timeInterval);
            timeInterval = setInterval(() => {
                if (gameStarted) {
                    timeLeft--;
                    timeLeftElement.textContent = timeLeft;
                    
                    if (timeLeft <= 10) {
                        timeLeftElement.classList.add('pulse');
                        timeLeftElement.style.color = '#ff3366';
                        timeLeftElement.style.borderColor = '#ff3366';
                    }
                    
                    if (timeLeft <= 0) stopGame();
                }
            }, 1000);
            
            // –ó–∞–ø—É—Å–∫–∞–µ–º —Å–ø–∞–≤–Ω –∫—É–±–æ–≤
            if (cubeSpawnInterval) clearInterval(cubeSpawnInterval);
            cubeSpawnInterval = setInterval(() => {
                if (gameStarted) {
                    createCube();
                    
                    const elapsed = Date.now() - gameStartTime;
                    if (elapsed > 30000 && Math.random() > 0.6) createCube();
                    if (elapsed > 60000 && Math.random() > 0.4) createCube();
                }
            }, CONFIG.CUBE_SPAWN_RATE);
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–∞–±–ª–∏
            sabers.left.group.visible = true;
            sabers.right.group.visible = true;
        }
        
        // –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –∏–≥—Ä—ã
        function stopGame() {
            gameStarted = false;
            
            if (cubeSpawnInterval) {
                clearInterval(cubeSpawnInterval);
                cubeSpawnInterval = null;
            }
            
            if (timeInterval) {
                clearInterval(timeInterval);
                timeInterval = null;
            }
            
            const elapsed = Math.floor((Date.now() - gameStartTime) / 1000);
            messageElement.textContent = `–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞! –í—Ä–µ–º—è: ${elapsed}—Å, –°—á–µ—Ç: ${score}, –ú–∞–∫—Å. –∫–æ–º–±–æ: ${maxCombo}`;
            startButton.textContent = "üöÄ –°–¢–ê–†–¢";
            timeLeftElement.classList.remove('hidden', 'pulse');
            timeLeftElement.style.color = '#00ff88';
            timeLeftElement.style.borderColor = '#00ff88';
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–≥—Ä–æ–≤–æ–π –ª–æ–≥–∏–∫–∏
        function updateGame() {
            if (!gameStarted) return;
            
            const currentTime = Date.now();
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –∫—É–±—ã
            for (let i = cubes.length - 1; i >= 0; i--) {
                const cube = cubes[i];
                cube.position.add(cube.userData.direction.clone().multiplyScalar(cube.userData.speed));
                cube.rotation.x += 0.02;
                cube.rotation.y += 0.02;
                
                // –ú–µ—Ä—Ü–∞–Ω–∏–µ —Å–≤–µ—á–µ–Ω–∏—è
                const glow = cube.children.find(c => c.material && c.material.opacity === 0.2);
                if (glow) {
                    glow.material.opacity = 0.2 + Math.sin(currentTime * 0.005 + i) * 0.1;
                }
                
                if (cube.position.z < CONFIG.CUBE_END_Z) {
                    scene.remove(cube);
                    cubes.splice(i, 1);
                    
                    missedCubes++;
                    combo = 0;
                    comboElement.textContent = `Combo: 0 (Max: ${maxCombo})`;
                    comboElement.style.color = '#00ff88';
                    comboElement.style.textShadow = '0 0 10px #00ff88';
                    
                    if (missedCubes >= CONFIG.MISS_LIMIT) {
                        messageElement.textContent = "–°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –ø—Ä–æ–ø—É—â–µ–Ω–æ!";
                        stopGame();
                    }
                }
            }
            
            // –¢–∞–π–º–∞—É—Ç –∫–æ–º–±–æ
            if (currentTime - lastCutTime > CONFIG.COMBO_TIMEOUT && combo > 0) {
                combo = 0;
                comboElement.textContent = `Combo: 0 (Max: ${maxCombo})`;
                comboElement.style.color = '#00ff88';
                comboElement.style.textShadow = '0 0 10px #00ff88';
            }
            
            // –û–±–Ω–æ–≤–ª—è–µ–º FPS
            frameCount++;
            if (currentTime - lastFpsTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastFpsTime = currentTime;
                fpsElement.textContent = `FPS: ${fps}`;
            }
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // –ê–Ω–∏–º–∞—Ü–∏–æ–Ω–Ω—ã–π —Ü–∏–∫–ª
        function animate() {
            requestAnimationFrame(animate);
            updateGame();
            renderer.render(scene, camera);
        }
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        async function init() {
            try {
                initThreeJS();
                
                const cameraSuccess = await initCamera();
                if (cameraSuccess) {
                    await initHandTracking();
                    animate();
                    messageElement.textContent = "–ì–æ—Ç–æ–≤–æ! –ù–∞–∂–º–∏—Ç–µ –°–¢–ê–†–¢ –∏–ª–∏ –ü–†–û–ë–ï–õ";
                }
                
                // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
                startButton.addEventListener('click', startGame);
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space') {
                        e.preventDefault();
                        startGame();
                    }
                    if (e.code === 'KeyD') {
                        handDebugElement.classList.toggle('hidden');
                    }
                });
                
                // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–ª—è –¥–µ–º–æ
                document.addEventListener('keydown', (e) => {
                    if (!gameStarted) return;
                    
                    if (e.code === 'ArrowLeft') {
                        updateSaberFromInput('left', -1.5, 1.5, 2);
                        checkSaberCollisions('left');
                    }
                    if (e.code === 'ArrowRight') {
                        updateSaberFromInput('right', 1.5, 1.5, 2);
                        checkSaberCollisions('right');
                    }
                });
                
            } catch (error) {
                console.error("Init error:", error);
                messageElement.textContent = "–û—à–∏–±–∫–∞: " + error.message;
            }
        }
        
        // –û—á–∏—Å—Ç–∫–∞
        window.addEventListener('beforeunload', () => {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
            }
        });
        
        // –ó–∞–ø—É—Å–∫
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
