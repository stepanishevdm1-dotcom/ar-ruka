<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Beat Saber Web</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #0a0a0a;
            color: white;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 2;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
        }
        
        #score {
            font-size: 36px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
        }
        
        #combo {
            font-size: 24px;
            color: #ffaa00;
            margin-bottom: 20px;
        }
        
        #message {
            font-size: 18px;
            color: #888;
            margin-top: 10px;
        }
        
        #startButton {
            background: linear-gradient(45deg, #ff0080, #00ff88);
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 18px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 10px;
            transition: transform 0.2s;
        }
        
        #startButton:hover {
            transform: scale(1.05);
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            z-index: 2;
            backdrop-filter: blur(5px);
            width: 90%;
            max-width: 500px;
        }
        
        .hand-indicator {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin: 0 5px;
        }
        
        #leftHandIndicator {
            background-color: #ff0080;
            box-shadow: 0 0 10px #ff0080;
        }
        
        #rightHandIndicator {
            background-color: #00ff88;
            box-shadow: 0 0 10px #00ff88;
        }
        
        #cameraStatus {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
            z-index: 2;
            font-size: 14px;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: white;
            z-index: 10;
        }
        
        #debug {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 2;
            display: none;
        }
        
        #debugToggle {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid #555;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            z-index: 3;
        }
        
        .hidden-canvas {
            position: absolute !important;
            top: -9999px !important;
            left: -9999px !important;
            width: 1px !important;
            height: 1px !important;
            opacity: 0 !important;
            pointer-events: none !important;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>
<body>
    <div id="container">
        <div id="ui">
            <div id="score">0</div>
            <div id="combo">Combo: 0</div>
            <div id="message">–ó–∞–≥—Ä—É–∂–∞—é –¥–µ—Ç–µ–∫—Ç–æ—Ä —Ä—É–∫...</div>
            <button id="startButton">–°–¢–ê–†–¢ –ò–ì–†–´</button>
        </div>
        
        <div id="cameraStatus">
            <div id="cameraIcon">üì∑</div>
            <div id="cameraText">–ö–∞–º–µ—Ä–∞ –∞–∫—Ç–∏–≤–Ω–∞</div>
        </div>
        
        <div id="instructions">
            <div style="margin-bottom: 10px;">
                <span class="hand-indicator" id="leftHandIndicator"></span> –õ–µ–≤–∞—è —Ä—É–∫–∞ —Ä–µ–∂–µ—Ç –∫—Ä–∞—Å–Ω—ã–µ –∫—É–±—ã
                <span style="margin: 0 15px">|</span>
                <span class="hand-indicator" id="rightHandIndicator"></span> –ü—Ä–∞–≤–∞—è —Ä—É–∫–∞ —Ä–µ–∂–µ—Ç —Å–∏–Ω–∏–µ –∫—É–±—ã
            </div>
            <div style="font-size: 14px; color: #aaa; margin-top: 5px;">
                –ö—É–±—ã –ª–µ—Ç—è—Ç –æ—Ç –∫–∞–º–µ—Ä—ã –∫ –≤–∞–º. –†–µ–∂—å—Ç–µ –∏—Ö —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–º–∏ —Ä—É–∫–∞–º–∏!
            </div>
        </div>
        
        <button id="debugToggle">Debug</button>
        <div id="debug">
            <div>FPS: <span id="fps">0</span></div>
            <div>–ö—É–±—ã: <span id="cubeCount">0</span></div>
            <div>–õ–µ–≤–∞—è —Ä—É–∫–∞: <span id="leftHandDebug">–Ω–µ—Ç</span></div>
            <div>–ü—Ä–∞–≤–∞—è —Ä—É–∫–∞: <span id="rightHandDebug">–Ω–µ—Ç</span></div>
        </div>
        
        <!-- –°–∫—Ä—ã—Ç—ã–π video —ç–ª–µ–º–µ–Ω—Ç –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–∞–º–µ—Ä—ã -->
        <video id="inputVideo" class="hidden-canvas" autoplay playsinline></video>
        
        <canvas id="gameCanvas"></canvas>
    </div>

    <script>
        // –û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã –∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let scene, camera, renderer, controls;
        let hands, cameraInstance;
        let gameStarted = false;
        let score = 0;
        let combo = 0;
        let maxCombo = 0;
        let missedCubes = 0;
        let cubes = [];
        let sabers = { left: null, right: null };
        let trails = { left: null, right: null };
        let lastCutTime = 0;
        let cubeSpawnInterval = null;
        let gameStartTime = 0;
        let debugMode = false;
        let frameCount = 0;
        let lastFpsUpdate = 0;
        let fps = 0;
        
        // –≠–ª–µ–º–µ–Ω—Ç—ã DOM
        const scoreElement = document.getElementById('score');
        const comboElement = document.getElementById('combo');
        const messageElement = document.getElementById('message');
        const startButton = document.getElementById('startButton');
        const leftHandIndicator = document.getElementById('leftHandIndicator');
        const rightHandIndicator = document.getElementById('rightHandIndicator');
        const videoElement = document.getElementById('inputVideo');
        const debugElement = document.getElementById('debug');
        const debugToggle = document.getElementById('debugToggle');
        const fpsElement = document.getElementById('fps');
        const cubeCountElement = document.getElementById('cubeCount');
        const leftHandDebug = document.getElementById('leftHandDebug');
        const rightHandDebug = document.getElementById('rightHandDebug');
        const cameraStatus = document.getElementById('cameraStatus');
        
        // –¶–≤–µ—Ç–∞
        const COLORS = {
            RED: 0xff3333,      // –õ–µ–≤–∞—è —Ä—É–∫–∞
            BLUE: 0x3399ff,     // –ü—Ä–∞–≤–∞—è —Ä—É–∫–∞
            GREEN: 0x33ff99,
            SABER_LEFT: 0xff3366,
            SABER_RIGHT: 0x33ccff,
            TRAIL_LEFT: 0xff3366,
            TRAIL_RIGHT: 0x33ccff,
            BACKGROUND: 0x0a0a0a,
            LASER_LEFT: 0xff0066,
            LASER_RIGHT: 0x00ccff
        };
        
        // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∏–≥—Ä—ã
        const GAME_CONFIG = {
            CUBE_SPAWN_RATE: 1000, // –º—Å –º–µ–∂–¥—É —Å–ø–∞–≤–Ω–æ–º –∫—É–±–æ–≤
            CUBE_SPEED_MIN: 0.08,
            CUBE_SPEED_MAX: 0.12,
            CUBE_LANE_POSITIONS: [-1.2, -0.4, 0.4, 1.2], // –ü–æ–∑–∏—Ü–∏–∏ –¥–æ—Ä–æ–∂–µ–∫
            CUBE_START_Z: 5,      // –ö—É–±—ã –Ω–∞—á–∏–Ω–∞—é—Ç –¥–∞–ª–µ–∫–æ (–±–ª–∏–∑–∫–æ –∫ –∫–∞–º–µ—Ä–µ)
            CUBE_END_Z: -3,       // –ö—É–±—ã –∏—Å—á–µ–∑–∞—é—Ç –∑–¥–µ—Å—å (–±–ª–∏–∑–∫–æ –∫ –∏–≥—Ä–æ–∫—É)
            SABER_LENGTH: 1.0,
            MISS_LIMIT: 10,       // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã—Ö –∫—É–±–æ–≤
            GAME_DURATION: 90000, // 90 —Å–µ–∫—É–Ω–¥
            COMBO_TIMEOUT: 2000   // 2 —Å–µ–∫—É–Ω–¥—ã –¥–ª—è –∫–æ–º–±–æ
        };
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Three.js —Å—Ü–µ–Ω—ã
        function initThreeJS() {
            // –°–æ–∑–¥–∞–µ–º —Å—Ü–µ–Ω—É
            scene = new THREE.Scene();
            scene.background = new THREE.Color(COLORS.BACKGROUND);
            scene.fog = new THREE.Fog(COLORS.BACKGROUND, 5, 15);
            
            // –°–æ–∑–¥–∞–µ–º –∫–∞–º–µ—Ä—É - –≤–∏–¥ –æ—Ç –ø–µ—Ä–≤–æ–≥–æ –ª–∏—Ü–∞
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1.6, 0); // –í—ã—Å–æ—Ç–∞ –≥–ª–∞–∑ —á–µ–ª–æ–≤–µ–∫–∞
            camera.lookAt(0, 1.6, -10);     // –°–º–æ—Ç—Ä–∏–º –≤–ø–µ—Ä–µ–¥
            
            // –°–æ–∑–¥–∞–µ–º —Ä–µ–Ω–¥–µ—Ä–µ—Ä
            const canvas = document.getElementById('gameCanvas');
            renderer = new THREE.WebGLRenderer({ 
                canvas, 
                antialias: true,
                alpha: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // –î–æ–±–∞–≤–ª—è–µ–º –æ—Å–≤–µ—â–µ–Ω–∏–µ
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            // –û—Å–Ω–æ–≤–Ω–æ–π –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π —Å–≤–µ—Ç —Å–ø–µ—Ä–µ–¥–∏ (–∫–∞–∫ –≤ Beat Saber)
            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mainLight.position.set(0, 3, 5);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 1024;
            mainLight.shadow.mapSize.height = 1024;
            scene.add(mainLight);
            
            // –ó–∞–¥–Ω—è—è –ø–æ–¥—Å–≤–µ—Ç–∫–∞
            const backLight = new THREE.DirectionalLight(0x223344, 0.3);
            backLight.position.set(0, 2, -5);
            scene.add(backLight);
            
            // –°–æ–∑–¥–∞–µ–º —Å–∞–±–ª–∏
            createSaber('left', COLORS.SABER_LEFT);
            createSaber('right', COLORS.SABER_RIGHT);
            
            // –°–æ–∑–¥–∞–µ–º —Å–ª–µ–¥—ã –æ—Ç —Å–∞–±–µ–ª—å
            createTrail('left', COLORS.TRAIL_LEFT);
            createTrail('right', COLORS.TRAIL_RIGHT);
            
            // –°–æ–∑–¥–∞–µ–º –∏–≥—Ä–æ–≤—É—é –∑–æ–Ω—É (—Ç—É–Ω–Ω–µ–ª—å –∫–∞–∫ –≤ Beat Saber)
            createGameTunnel();
            
            // –°–æ–∑–¥–∞–µ–º –ª–∞–∑–µ—Ä–Ω—ã–µ —É–∫–∞–∑–∞—Ç–µ–ª–∏
            createLaserPointers();
            
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞
            window.addEventListener('resize', onWindowResize);
            
            messageElement.textContent = "–î–µ—Ç–µ–∫—Ç–æ—Ä —Ä—É–∫ –≥–æ—Ç–æ–≤! –ù–∞–∂–º–∏—Ç–µ –°–¢–ê–†–¢ –ò–ì–†–´";
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –∏–≥—Ä–æ–≤–æ–≥–æ —Ç—É–Ω–Ω–µ–ª—è (–∫–∞–∫ –≤ Beat Saber)
        function createGameTunnel() {
            // –ü–æ–ª —Ç—É–Ω–Ω–µ–ª—è
            const floorGeometry = new THREE.PlaneGeometry(6, 30);
            const floorMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x111122,
                shininess: 10,
                side: THREE.DoubleSide
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = Math.PI / 2;
            floor.position.y = -1;
            floor.position.z = -10;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // –°–æ–∑–¥–∞–µ–º –¥–æ—Ä–æ–∂–∫–∏ –¥–ª—è –∫—É–±–æ–≤
            const laneMaterial = new THREE.LineBasicMaterial({
                color: 0x333355,
                transparent: true,
                opacity: 0.3,
                linewidth: 2
            });
            
            GAME_CONFIG.CUBE_LANE_POSITIONS.forEach(x => {
                // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏ –¥–æ—Ä–æ–∂–µ–∫
                const laneGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(x, 0.5, GAME_CONFIG.CUBE_START_Z),
                    new THREE.Vector3(x, 0.5, GAME_CONFIG.CUBE_END_Z)
                ]);
                
                const lane = new THREE.Line(laneGeometry, laneMaterial);
                scene.add(lane);
                
                // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –Ω–∞–ø—Ä–∞–≤–ª—è—é—â–∏–µ
                for (let z = GAME_CONFIG.CUBE_START_Z; z > GAME_CONFIG.CUBE_END_Z; z -= 2) {
                    const guideGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(x - 0.3, 0.5, z),
                        new THREE.Vector3(x + 0.3, 0.5, z)
                    ]);
                    
                    const guide = new THREE.Line(guideGeometry, laneMaterial);
                    scene.add(guide);
                }
            });
            
            // –°–æ–∑–¥–∞–µ–º –∫–æ–Ω–µ—á–Ω—É—é —Å—Ç–µ–Ω—É (–≥–¥–µ –∫—É–±—ã –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —Ä–∞–∑—Ä–µ–∑–∞–Ω—ã)
            const wallGeometry = new THREE.PlaneGeometry(5, 3);
            const wallMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x222244,
                transparent: true,
                opacity: 0.1,
                side: THREE.DoubleSide
            });
            
            const endWall = new THREE.Mesh(wallGeometry, wallMaterial);
            endWall.position.z = GAME_CONFIG.CUBE_END_Z;
            endWall.position.y = 1.5;
            scene.add(endWall);
            
            // –î–æ–±–∞–≤–ª—è–µ–º —ç—Ñ—Ñ–µ–∫—Ç "—Ç—É–Ω–Ω–µ–ª—è" —Å –ø–æ–º–æ—â—å—é —á–∞—Å—Ç–∏—Ü –Ω–∞ –∑–∞–¥–Ω–µ–º –ø–ª–∞–Ω–µ
            createTunnelEffect();
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ —Ç—É–Ω–Ω–µ–ª—è
        function createTunnelEffect() {
            const particleCount = 200;
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 2 + Math.random() * 4;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * 1.5;
                const z = -Math.random() * 40;
                
                vertices.push(x, y, z);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            
            const material = new THREE.PointsMaterial({
                color: 0x4488ff,
                size: 0.05,
                transparent: true,
                opacity: 0.3
            });
            
            const particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —Å–∞–±–ª–∏
        function createSaber(side, color) {
            const group = new THREE.Group();
            
            // –†—É–∫–æ—è—Ç—å —Å–∞–±–ª–∏
            const handleGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.25, 8);
            const handleMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x222222,
                shininess: 100,
                emissive: 0x111111,
                emissiveIntensity: 0.2
            });
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.position.y = 0.125;
            group.add(handle);
            
            // –õ–µ–∑–≤–∏–µ —Å–∞–±–ª–∏
            const bladeGeometry = new THREE.BoxGeometry(0.03, GAME_CONFIG.SABER_LENGTH, 0.03);
            const bladeMaterial = new THREE.MeshPhongMaterial({ 
                color: color,
                emissive: color,
                emissiveIntensity: 0.8,
                shininess: 100,
                transparent: true,
                opacity: 0.95
            });
            const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
            blade.position.y = GAME_CONFIG.SABER_LENGTH / 2 + 0.25;
            group.add(blade);
            
            // –°–≤–µ—á–µ–Ω–∏–µ –ª–µ–∑–≤–∏—è
            const glowGeometry = new THREE.CylinderGeometry(0.045, 0.045, GAME_CONFIG.SABER_LENGTH + 0.1, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.15,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.y = GAME_CONFIG.SABER_LENGTH / 2 + 0.25;
            group.add(glow);
            
            scene.add(group);
            sabers[side] = {
                group: group,
                blade: blade,
                glow: glow,
                position: new THREE.Vector3(),
                velocity: new THREE.Vector3(),
                lastPosition: new THREE.Vector3(),
                isDetected: false,
                isCutting: false
            };
            
            // –ò–∑–Ω–∞—á–∞–ª—å–Ω–æ —Å–∫—Ä—ã–≤–∞–µ–º —Å–∞–±–ª–∏
            group.visible = false;
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –ª–∞–∑–µ—Ä–Ω—ã—Ö —É–∫–∞–∑–∞—Ç–µ–ª–µ–π –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
        function createLaserPointers() {
            // –õ–∞–∑–µ—Ä –¥–ª—è –ª–µ–≤–æ–π —Ä—É–∫–∏
            const leftLaserGeometry = new THREE.CylinderGeometry(0.005, 0.005, 10, 8);
            const leftLaserMaterial = new THREE.MeshBasicMaterial({
                color: COLORS.LASER_LEFT,
                transparent: true,
                opacity: 0.3
            });
            const leftLaser = new THREE.Mesh(leftLaserGeometry, leftLaserMaterial);
            leftLaser.rotation.x = Math.PI / 2;
            scene.add(leftLaser);
            sabers.left.laser = leftLaser;
            leftLaser.visible = false;
            
            // –õ–∞–∑–µ—Ä –¥–ª—è –ø—Ä–∞–≤–æ–π —Ä—É–∫–∏
            const rightLaserGeometry = new THREE.CylinderGeometry(0.005, 0.005, 10, 8);
            const rightLaserMaterial = new THREE.MeshBasicMaterial({
                color: COLORS.LASER_RIGHT,
                transparent: true,
                opacity: 0.3
            });
            const rightLaser = new THREE.Mesh(rightLaserGeometry, rightLaserMaterial);
            rightLaser.rotation.x = Math.PI / 2;
            scene.add(rightLaser);
            sabers.right.laser = rightLaser;
            rightLaser.visible = false;
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —Å–ª–µ–¥–∞ –æ—Ç —Å–∞–±–ª–∏
        function createTrail(side, color) {
            const trailGeometry = new THREE.BufferGeometry();
            const trailMaterial = new THREE.LineBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.6,
                linewidth: 3
            });
            
            const trail = new THREE.Line(trailGeometry, trailMaterial);
            scene.add(trail);
            
            trails[side] = {
                line: trail,
                points: [],
                maxPoints: 15
            };
            
            trail.visible = false;
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –ª–µ—Ç—è—â–µ–≥–æ –∫—É–±–∞
        function createCube() {
            // –°–ª—É—á–∞–π–Ω–æ –≤—ã–±–∏—Ä–∞–µ–º —Ü–≤–µ—Ç –∏ —Å—Ç–æ—Ä–æ–Ω—É
            const isLeft = Math.random() > 0.5;
            const color = isLeft ? COLORS.RED : COLORS.BLUE;
            const targetHand = isLeft ? 'left' : 'right';
            
            // –°–ª—É—á–∞–π–Ω–æ –≤—ã–±–∏—Ä–∞–µ–º –¥–æ—Ä–æ–∂–∫—É –¥–ª—è —ç—Ç–æ–≥–æ —Ç–∏–ø–∞ —Ä—É–∫–∏
            const lanePositions = isLeft 
                ? GAME_CONFIG.CUBE_LANE_POSITIONS.filter((_, i) => i < 2) // –î–≤–µ –ª–µ–≤—ã–µ –¥–æ—Ä–æ–∂–∫–∏
                : GAME_CONFIG.CUBE_LANE_POSITIONS.filter((_, i) => i >= 2); // –î–≤–µ –ø—Ä–∞–≤—ã–µ –¥–æ—Ä–æ–∂–∫–∏
            
            const lane = lanePositions[Math.floor(Math.random() * lanePositions.length)];
            
            const geometry = new THREE.BoxGeometry(0.6, 0.6, 0.6);
            const material = new THREE.MeshPhongMaterial({ 
                color: color,
                emissive: color,
                emissiveIntensity: 0.3,
                shininess: 100,
                transparent: true,
                opacity: 0.9
            });
            
            const cube = new THREE.Mesh(geometry, material);
            cube.castShadow = true;
            cube.receiveShadow = true;
            
            // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º –∫—É–± –≤ –Ω–∞—á–∞–ª–µ —Ç—É–Ω–Ω–µ–ª—è (–±–ª–∏–∑–∫–æ –∫ –∫–∞–º–µ—Ä–µ)
            cube.position.x = lane;
            cube.position.y = 1.5; // –ù–∞ —É—Ä–æ–≤–Ω–µ –≥—Ä—É–¥–∏
            cube.position.z = GAME_CONFIG.CUBE_START_Z; // –ù–∞—á–∏–Ω–∞–µ–º –¥–∞–ª–µ–∫–æ (–±–ª–∏–∑–∫–æ –∫ –∫–∞–º–µ—Ä–µ)
            
            // –î–æ–±–∞–≤–ª—è–µ–º —Å—Ç—Ä–µ–ª–∫—É –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –Ω–∞ –∫—É–±
            const arrowGeometry = new THREE.ConeGeometry(0.15, 0.3, 4);
            const arrowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                transparent: true,
                opacity: 0.8
            });
            const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
            arrow.rotation.x = Math.PI; // –°–º–æ—Ç—Ä–∏—Ç –≤–ø–µ—Ä–µ–¥ (–∫ –∏–≥—Ä–æ–∫—É)
            arrow.position.z = -0.35; // –ù–∞ –ø–µ—Ä–µ–¥–Ω–µ–π –≥—Ä–∞–Ω–∏ –∫—É–±–∞
            cube.add(arrow);
            
            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∫—É–±–∞
            cube.userData = {
                targetHand: targetHand,
                color: color,
                speed: GAME_CONFIG.CUBE_SPEED_MIN + Math.random() * (GAME_CONFIG.CUBE_SPEED_MAX - GAME_CONFIG.CUBE_SPEED_MIN),
                direction: new THREE.Vector3(0, 0, -1), // –õ–µ—Ç–∏—Ç –æ—Ç –∫–∞–º–µ—Ä—ã –∫ –∏–≥—Ä–æ–∫—É!
                spawnTime: Date.now(),
                isActive: true,
                lane: lane
            };
            
            scene.add(cube);
            cubes.push(cube);
            
            return cube;
        }
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –¥–µ—Ç–µ–∫—Ç–æ—Ä–∞ —Ä—É–∫
        async function initHandDetection() {
            hands = new self.Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });
            
            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7,
                selfieMode: true // –í–∞–∂–Ω–æ! –î–ª—è —Ñ—Ä–æ–Ω—Ç–∞–ª—å–Ω–æ–π –∫–∞–º–µ—Ä—ã
            });
            
            hands.onResults(onHandResults);
            
            // –ó–∞–ø—É—Å–∫–∞–µ–º –∫–∞–º–µ—Ä—É –≤ —Å–∫—Ä—ã—Ç–æ–º —Ä–µ–∂–∏–º–µ
            const camera = new self.Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({ image: videoElement });
                },
                width: 640,
                height: 480
            });
            
            try {
                await camera.start();
                cameraStatus.style.color = '#00ff88';
                cameraStatus.querySelector('#cameraIcon').textContent = '‚úÖ';
                cameraStatus.querySelector('#cameraText').textContent = '–ö–∞–º–µ—Ä–∞ –∞–∫—Ç–∏–≤–Ω–∞';
                messageElement.textContent = "–ö–∞–º–µ—Ä–∞ –∑–∞–ø—É—â–µ–Ω–∞! –ù–∞–∂–º–∏—Ç–µ –°–¢–ê–†–¢ –ò–ì–†–´";
            } catch (error) {
                console.error("Camera error:", error);
                cameraStatus.style.color = '#ff3333';
                cameraStatus.querySelector('#cameraIcon').textContent = '‚ùå';
                cameraStatus.querySelector('#cameraText').textContent = '–û—à–∏–±–∫–∞ –∫–∞–º–µ—Ä—ã';
                messageElement.textContent = "–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –∫–∞–º–µ—Ä–µ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è.";
            }
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –¥–µ—Ç–µ–∫—Ü–∏–∏ —Ä—É–∫
        function onHandResults(results) {
            if (!gameStarted) return;
            
            // –°–±—Ä–æ—Å–∏—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è
            sabers.left.isDetected = false;
            sabers.right.isDetected = false;
            leftHandIndicator.style.backgroundColor = '#555';
            rightHandIndicator.style.backgroundColor = '#555';
            
            if (debugMode) {
                leftHandDebug.textContent = '–Ω–µ—Ç';
                rightHandDebug.textContent = '–Ω–µ—Ç';
            }
            
            if (results.multiHandLandmarks && results.multiHandedness) {
                for (let i = 0; i < Math.min(results.multiHandLandmarks.length, 2); i++) {
                    const landmarks = results.multiHandLandmarks[i];
                    const handedness = results.multiHandedness[i].label; // "Left" –∏–ª–∏ "Right"
                    
                    // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ—á–∫—É –Ω–∞ –∑–∞–ø—è—Å—Ç—å–µ (landmark 0) –∏ —Å—Ä–µ–¥–Ω—é—é —Ç–æ—á–∫—É –ª–∞–¥–æ–Ω–∏
                    const wrist = landmarks[0];
                    const middleBase = landmarks[9]; // –û—Å–Ω–æ–≤–∞–Ω–∏–µ –ª–∞–¥–æ–Ω–∏
                    
                    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã MediaPipe –≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã Three.js
                    // MediaPipe: x,y –æ—Ç 0 –¥–æ 1, z - –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–∞—è –≥–ª—É–±–∏–Ω–∞
                    // Three.js: —Å–∏—Å—Ç–µ–º–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –æ—Ç –ø–µ—Ä–≤–æ–≥–æ –ª–∏—Ü–∞
                    
                    // X: —Å–ª–µ–≤–∞ –Ω–∞–ø—Ä–∞–≤–æ (-2 –¥–æ 2)
                    const x = (wrist.x - 0.5) * 4;
                    
                    // Y: —Å–Ω–∏–∑—É –≤–≤–µ—Ä—Ö, –∏–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º (0.5 - y)
                    const y = (0.5 - wrist.y) * 3 + 0.5;
                    
                    // Z: –≥–ª—É–±–∏–Ω–∞ (–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–∞—è - –≤–ø–µ—Ä–µ–¥–∏ –∏–≥—Ä–æ–∫–∞)
                    const z = -(wrist.z * 3 + 1);
                    
                    const handKey = handedness.toLowerCase(); // "left" –∏–ª–∏ "right"
                    
                    if (sabers[handKey]) {
                        const saber = sabers[handKey];
                        const newPosition = new THREE.Vector3(x, y, z);
                        
                        // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å
                        if (saber.lastPosition.x !== 0 || saber.lastPosition.y !== 0 || saber.lastPosition.z !== 0) {
                            saber.velocity.subVectors(newPosition, saber.lastPosition);
                        }
                        saber.lastPosition.copy(saber.position);
                        saber.position.copy(newPosition);
                        
                        // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é —Å–∞–±–ª–∏
                        saber.group.position.copy(saber.position);
                        
                        // –í—Ä–∞—â–∞–µ–º —Å–∞–±–ª—é –≤ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ –¥–≤–∏–∂–µ–Ω–∏—è (–µ—Å–ª–∏ –µ—Å—Ç—å —Å–∫–æ—Ä–æ—Å—Ç—å)
                        if (saber.velocity.length() > 0.01) {
                            const targetPos = saber.position.clone().add(saber.velocity.normalize());
                            saber.group.lookAt(targetPos);
                        } else {
                            // –ë–∞–∑–æ–≤–∞—è –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏—è - –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ
                            saber.group.rotation.set(0, 0, 0);
                        }
                        
                        // –û–±–Ω–æ–≤–ª—è–µ–º —Å–ª–µ–¥
                        const trailPos = saber.position.clone();
                        trailPos.y += 0.3; // –°–ª–µ–¥ –Ω–µ–º–Ω–æ–≥–æ –≤—ã—à–µ
                        updateTrail(handKey, trailPos);
                        
                        // –û–±–Ω–æ–≤–ª—è–µ–º –ª–∞–∑–µ—Ä–Ω—ã–π —É–∫–∞–∑–∞—Ç–µ–ª—å
                        if (saber.laser) {
                            saber.laser.position.copy(saber.position);
                            saber.laser.position.y += 0.3;
                            
                            // –ù–∞–ø—Ä–∞–≤–ª—è–µ–º –ª–∞–∑–µ—Ä –≤–ø–µ—Ä–µ–¥
                            saber.laser.rotation.z = Math.atan2(x, -z);
                            saber.laser.visible = debugMode;
                        }
                        
                        saber.isDetected = true;
                        saber.group.visible = true;
                        
                        // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä
                        const indicator = handKey === 'left' ? leftHandIndicator : rightHandIndicator;
                        indicator.style.backgroundColor = handKey === 'left' ? '#ff3366' : '#33ccff';
                        indicator.style.boxShadow = `0 0 10px ${handKey === 'left' ? '#ff3366' : '#33ccff'}`;
                        
                        if (debugMode) {
                            if (handKey === 'left') {
                                leftHandDebug.textContent = `x:${x.toFixed(2)} y:${y.toFixed(2)} z:${z.toFixed(2)}`;
                            } else {
                                rightHandDebug.textContent = `x:${x.toFixed(2)} y:${y.toFixed(2)} z:${z.toFixed(2)}`;
                            }
                        }
                        
                        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–ª–∏–∑–∏–∏ —Å –∫—É–±–∞–º–∏
                        checkCollisions(handKey);
                    }
                }
            }
            
            // –°–∫—Ä—ã–≤–∞–µ–º –Ω–µ–æ–±–Ω–∞—Ä—É–∂–µ–Ω–Ω—ã–µ —Å–∞–±–ª–∏
            if (!sabers.left.isDetected) {
                sabers.left.group.visible = false;
                trails.left.line.visible = false;
                if (sabers.left.laser) sabers.left.laser.visible = false;
            }
            if (!sabers.right.isDetected) {
                sabers.right.group.visible = false;
                trails.right.line.visible = false;
                if (sabers.right.laser) sabers.right.laser.visible = false;
            }
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–ª–µ–¥–∞ —Å–∞–±–ª–∏
        function updateTrail(side, position) {
            const trail = trails[side];
            if (!trail || !sabers[side].isDetected) return;
            
            // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—É—é —Ç–æ—á–∫—É
            trail.points.unshift(position.clone());
            
            // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ—á–µ–∫
            if (trail.points.length > trail.maxPoints) {
                trail.points.pop();
            }
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –≥–µ–æ–º–µ—Ç—Ä–∏—é
            if (trail.points.length > 1) {
                const positions = new Float32Array(trail.points.length * 3);
                for (let i = 0; i < trail.points.length; i++) {
                    positions[i * 3] = trail.points[i].x;
                    positions[i * 3 + 1] = trail.points[i].y;
                    positions[i * 3 + 2] = trail.points[i].z;
                }
                
                trail.line.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                trail.line.geometry.attributes.position.needsUpdate = true;
                trail.line.visible = true;
            }
        }
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π —Å –∫—É–±–∞–º–∏
        function checkCollisions(handKey) {
            const saber = sabers[handKey];
            if (!saber || !saber.isDetected) return;
            
            // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ª—É—á –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–æ–ª–ª–∏–∑–∏–π (–æ—Ç —Å–∞–±–ª–∏ –≤–ø–µ—Ä–µ–¥)
            const saberDirection = new THREE.Vector3(0, 0, -1);
            saberDirection.applyQuaternion(saber.group.quaternion);
            
            const raycaster = new THREE.Raycaster(
                saber.position,
                saberDirection,
                0,
                1.0 // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –¥–∏—Å—Ç–∞–Ω—Ü–∏—è
            );
            
            // –¢–∞–∫–∂–µ –ø—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ñ–µ—Ä–æ–π –¥–ª—è –±–æ–ª–µ–µ –Ω–∞–¥–µ–∂–Ω–æ–≥–æ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è
            const saberSphere = new THREE.Sphere(saber.position, 0.3);
            
            for (let i = cubes.length - 1; i >= 0; i--) {
                const cube = cubes[i];
                if (!cube.userData.isActive) continue;
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø–æ–¥—Ö–æ–¥—è—â–∞—è –ª–∏ —ç—Ç–æ —Ä—É–∫–∞ –¥–ª—è —ç—Ç–æ–≥–æ –∫—É–±–∞
                if (cube.userData.targetHand !== handKey) continue;
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ —Å –ø–æ–º–æ—â—å—é —Å—Ñ–µ—Ä—ã
                const cubeSphere = new THREE.Sphere(cube.position, 0.4);
                
                if (saberSphere.intersectsSphere(cubeSphere)) {
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å —É–¥–∞—Ä–∞
                    const saberSpeed = saber.velocity.length();
                    
                    if (saberSpeed > 0.05) { // –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –¥–ª—è –∑–∞—Å—á–∏—Ç—ã–≤–∞–Ω–∏—è —É–¥–∞—Ä–∞
                        cutCube(cube, handKey, saberSpeed);
                        cubes.splice(i, 1);
                        saber.isCutting = true;
                        setTimeout(() => saber.isCutting = false, 100);
                    }
                }
            }
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–∞–∑—Ä–µ–∑–∞–Ω–∏—è –∫—É–±–∞
        function cutCube(cube, handKey, speed) {
            cube.userData.isActive = false;
            
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ç–∞–π–º–µ—Ä –∫–æ–º–±–æ
            lastCutTime = Date.now();
            
            // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –∫–æ–º–±–æ –∏ —Å—á–µ—Ç
            combo++;
            const points = Math.floor(10 * combo * Math.min(speed * 10, 2));
            score += points;
            
            if (combo > maxCombo) {
                maxCombo = combo;
            }
            
            // –û–±–Ω–æ–≤–ª—è–µ–º UI
            scoreElement.textContent = score;
            comboElement.textContent = `Combo: ${combo} (Max: ${maxCombo})`;
            comboElement.style.color = combo >= 10 ? '#ffaa00' : '#00ff88';
            
            // –í–∏–∑—É–∞–ª—å–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã –ø—Ä–∏ —Ä–∞–∑—Ä–µ–∑–∞–Ω–∏–∏
            const color = cube.userData.color;
            
            // –í–∑—Ä—ã–≤ —á–∞—Å—Ç–∏—Ü
            createParticleExplosion(cube.position, color, speed);
            
            // –ó–≤—É–∫–æ–≤–æ–π —ç—Ñ—Ñ–µ–∫—Ç (–≤–∏–±—Ä–∞—Ü–∏—è)
            if (navigator.vibrate) {
                navigator.vibrate(30);
            }
            
            // –ê–Ω–∏–º–∞—Ü–∏—è —Ä–∞–∑—Ä–µ–∑–∞–Ω–∏—è - —Ä–∞–∑–¥–µ–ª—è–µ–º –∫—É–± –Ω–∞ –¥–≤–µ —á–∞—Å—Ç–∏
            createCubeSlice(cube, handKey === 'left' ? 1 : -1);
            
            // –£–¥–∞–ª—è–µ–º –∫—É–± —Å–æ —Å—Ü–µ–Ω—ã
            scene.remove(cube);
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –∞–Ω–∏–º–∞—Ü–∏–∏ —Ä–∞–∑—Ä–µ–∑–∞–Ω–∏—è –∫—É–±–∞
        function createCubeSlice(cube, direction) {
            const color = cube.userData.color;
            
            // –°–æ–∑–¥–∞–µ–º –¥–≤–µ –ø–æ–ª–æ–≤–∏–Ω–∫–∏ –∫—É–±–∞
            const halfGeometry = new THREE.BoxGeometry(0.6, 0.6, 0.3);
            const halfMaterial = new THREE.MeshPhongMaterial({ 
                color: color,
                emissive: color,
                emissiveIntensity: 0.5
            });
            
            const half1 = new THREE.Mesh(halfGeometry, halfMaterial);
            const half2 = new THREE.Mesh(halfGeometry, halfMaterial);
            
            half1.position.copy(cube.position);
            half1.position.x -= 0.15 * direction;
            half1.position.z -= 0.15;
            
            half2.position.copy(cube.position);
            half2.position.x += 0.15 * direction;
            half2.position.z += 0.15;
            
            scene.add(half1);
            scene.add(half2);
            
            // –ê–Ω–∏–º–∞—Ü–∏—è —Ä–∞–∑–ª–µ—Ç–∞ –ø–æ–ª–æ–≤–∏–Ω–æ–∫
            const velocity1 = new THREE.Vector3(-0.5 * direction, 0.2, -0.3);
            const velocity2 = new THREE.Vector3(0.5 * direction, 0.2, 0.3);
            
            function animateSlice() {
                half1.position.add(velocity1);
                half2.position.add(velocity2);
                
                half1.rotation.x += 0.1;
                half1.rotation.y += 0.1;
                half2.rotation.x += 0.1;
                half2.rotation.y += 0.1;
                
                velocity1.y -= 0.02; // –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏—è
                velocity2.y -= 0.02;
                
                halfMaterial.opacity -= 0.03;
                
                if (halfMaterial.opacity <= 0) {
                    scene.remove(half1);
                    scene.remove(half2);
                    return;
                }
                
                requestAnimationFrame(animateSlice);
            }
            
            animateSlice();
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –≤–∑—Ä—ã–≤–∞ —á–∞—Å—Ç–∏—Ü
        function createParticleExplosion(position, color, speed) {
            const particleCount = Math.floor(15 * speed);
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 0.5;
                const x = Math.cos(angle) * radius;
                const y = Math.random() * 0.5;
                const z = Math.sin(angle) * radius;
                vertices.push(x, y, z);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            
            const material = new THREE.PointsMaterial({
                color: color,
                size: 0.05 * (1 + speed),
                transparent: true,
                opacity: 0.8
            });
            
            const particles = new THREE.Points(geometry, material);
            particles.position.copy(position);
            scene.add(particles);
            
            // –ê–Ω–∏–º–∞—Ü–∏—è —á–∞—Å—Ç–∏—Ü
            const particleData = [];
            for (let i = 0; i < particleCount; i++) {
                particleData.push({
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.3,
                        (Math.random() - 0.5) * 0.3,
                        (Math.random() - 0.5) * 0.3
                    ),
                    life: 1.0
                });
            }
            
            function animateParticles() {
                let allDead = true;
                const positions = particles.geometry.attributes.position.array;
                
                for (let i = 0; i < particleCount; i++) {
                    const data = particleData[i];
                    if (data.life > 0) {
                        allDead = false;
                        data.life -= 0.05;
                        
                        positions[i * 3] += data.velocity.x;
                        positions[i * 3 + 1] += data.velocity.y;
                        positions[i * 3 + 2] += data.velocity.z;
                        
                        data.velocity.y -= 0.01; // –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏—è
                    }
                }
                
                particles.geometry.attributes.position.needsUpdate = true;
                material.opacity -= 0.03;
                material.size -= 0.001;
                
                if (allDead || material.opacity <= 0) {
                    scene.remove(particles);
                    return;
                }
                
                requestAnimationFrame(animateParticles);
            }
            
            animateParticles();
        }
        
        // –ó–∞–ø—É—Å–∫ –∏–≥—Ä—ã
        function startGame() {
            if (gameStarted) {
                stopGame();
                return;
            }
            
            gameStarted = true;
            gameStartTime = Date.now();
            score = 0;
            combo = 0;
            maxCombo = 0;
            missedCubes = 0;
            
            // –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ –∫—É–±—ã
            cubes.forEach(cube => scene.remove(cube));
            cubes = [];
            
            // –û–±–Ω–æ–≤–ª—è–µ–º UI
            scoreElement.textContent = "0";
            comboElement.textContent = "Combo: 0 (Max: 0)";
            comboElement.style.color = '#00ff88';
            messageElement.textContent = "–ò–≥—Ä–∞ –Ω–∞—á–∞–ª–∞—Å—å! –†–µ–∂—å—Ç–µ –∫—É–±—ã!";
            startButton.textContent = "–û–°–¢–ê–ù–û–í–ò–¢–¨ –ò–ì–†–£";
            
            // –ó–∞–ø—É—Å–∫–∞–µ–º —Å–ø–∞–≤–Ω –∫—É–±–æ–≤
            if (cubeSpawnInterval) clearInterval(cubeSpawnInterval);
            cubeSpawnInterval = setInterval(() => {
                if (gameStarted) {
                    createCube();
                    
                    // –ü–æ—Å—Ç–µ–ø–µ–Ω–Ω–æ —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å–ª–æ–∂–Ω–æ—Å—Ç—å
                    const elapsed = Date.now() - gameStartTime;
                    if (elapsed > 30000) { // –ü–æ—Å–ª–µ 30 —Å–µ–∫—É–Ω–¥
                        if (Math.random() > 0.7) createCube(); // –ò–Ω–æ–≥–¥–∞ –¥–≤–∞ –∫—É–±–∞
                    }
                    if (elapsed > 60000) { // –ü–æ—Å–ª–µ 60 —Å–µ–∫—É–Ω–¥
                        if (Math.random() > 0.5) createCube(); // –ß–∞—â–µ –¥–≤–∞ –∫—É–±–∞
                    }
                }
            }, GAME_CONFIG.CUBE_SPAWN_RATE);
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤ —Ä—É–∫
            leftHandIndicator.style.backgroundColor = '#555';
            rightHandIndicator.style.backgroundColor = '#555';
        }
        
        // –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –∏–≥—Ä—ã
        function stopGame() {
            gameStarted = false;
            
            if (cubeSpawnInterval) {
                clearInterval(cubeSpawnInterval);
                cubeSpawnInterval = null;
            }
            
            const elapsed = Math.floor((Date.now() - gameStartTime) / 1000);
            messageElement.textContent = `–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞! –í—Ä–µ–º—è: ${elapsed}—Å, –°—á–µ—Ç: ${score}, –ú–∞–∫—Å. –∫–æ–º–±–æ: ${maxCombo}`;
            startButton.textContent = "–ù–û–í–ê–Ø –ò–ì–†–ê";
            
            // –°–∫—Ä—ã–≤–∞–µ–º —Å–∞–±–ª–∏
            sabers.left.group.visible = false;
            sabers.right.group.visible = false;
            trails.left.line.visible = false;
            trails.right.line.visible = false;
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–≥—Ä–æ–≤–æ–π –ª–æ–≥–∏–∫–∏
        function updateGame() {
            if (!gameStarted) return;
            
            const currentTime = Date.now();
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –∫—É–±—ã
            for (let i = cubes.length - 1; i >= 0; i--) {
                const cube = cubes[i];
                
                // –î–≤–∏–≥–∞–µ–º –∫—É–± –ö –ò–ì–†–û–ö–£ (–æ—Ç –∫–∞–º–µ—Ä—ã –∫ –∏–≥—Ä–æ–∫—É)
                cube.position.add(cube.userData.direction.clone().multiplyScalar(cube.userData.speed));
                
                // –í—Ä–∞—â–∞–µ–º –∫—É–±
                cube.rotation.x += 0.01;
                cube.rotation.y += 0.01;
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —É–ª–µ—Ç–µ–ª –ª–∏ –∫—É–± —Å–ª–∏—à–∫–æ–º –¥–∞–ª–µ–∫–æ (–∑–∞ –∏–≥—Ä–æ–∫–∞)
                if (cube.position.z < GAME_CONFIG.CUBE_END_Z) {
                    // –ö—É–±—ã, –∫–æ—Ç–æ—Ä—ã–µ —É–ª–µ—Ç–µ–ª–∏ –∑–∞ –∏–≥—Ä–æ–∫–∞ (–ø—Ä–æ–ø—É—â–µ–Ω—ã)
                    cube.userData.isActive = false;
                    scene.remove(cube);
                    cubes.splice(i, 1);
                    
                    missedCubes++;
                    combo = 0; // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –∫–æ–º–±–æ –ø—Ä–∏ –ø—Ä–æ–ø—É—Å–∫–µ
                    comboElement.textContent = `Combo: 0 (Max: ${maxCombo})`;
                    comboElement.style.color = '#00ff88';
                    
                    // –ó–∞–∫–∞–Ω—á–∏–≤–∞–µ–º –∏–≥—Ä—É –ø—Ä–∏ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–µ –ø—Ä–æ–ø—É—Å–∫–æ–≤
                    if (missedCubes >= GAME_CONFIG.MISS_LIMIT) {
                        stopGame();
                        return;
                    }
                }
            }
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∞–π–º–∞—É—Ç –∫–æ–º–±–æ (–µ—Å–ª–∏ –¥–æ–ª–≥–æ –Ω–µ —Ä–µ–∑–∞–ª–∏ –∫—É–±—ã)
            if (currentTime - lastCutTime > GAME_CONFIG.COMBO_TIMEOUT && combo > 0) {
                combo = 0;
                comboElement.textContent = `Combo: 0 (Max: ${maxCombo})`;
                comboElement.style.color = '#00ff88';
            }
            
            // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–∫–æ–Ω—á–∞–Ω–∏–µ –∏–≥—Ä—ã —á–µ—Ä–µ–∑ –∑–∞–¥–∞–Ω–Ω–æ–µ –≤—Ä–µ–º—è
            if (currentTime - gameStartTime > GAME_CONFIG.GAME_DURATION) {
                stopGame();
            }
            
            // –û–±–Ω–æ–≤–ª—è–µ–º FPS —Å—á–µ—Ç—á–∏–∫
            frameCount++;
            if (currentTime - lastFpsUpdate >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastFpsUpdate = currentTime;
                
                if (debugMode) {
                    fpsElement.textContent = fps;
                    cubeCountElement.textContent = cubes.length;
                }
            }
        }
        
        // –ê–Ω–∏–º–∞—Ü–∏–æ–Ω–Ω—ã–π —Ü–∏–∫–ª
        function animate() {
            requestAnimationFrame(animate);
            
            updateGame();
            renderer.render(scene, camera);
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        async function init() {
            try {
                // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º Three.js
                initThreeJS();
                
                // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –¥–µ—Ç–µ–∫—Ç–æ—Ä —Ä—É–∫
                await initHandDetection();
                
                // –ó–∞–ø—É—Å–∫–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏–æ–Ω–Ω—ã–π —Ü–∏–∫–ª
                animate();
                
                // –ù–∞–∑–Ω–∞—á–∞–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏
                startButton.addEventListener('click', startGame);
                
                // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∞–≤–∏—à–∏ –ø—Ä–æ–±–µ–ª–∞ –¥–ª—è —Å—Ç–∞—Ä—Ç–∞ –∏–≥—Ä—ã
                document.addEventListener('keydown', (event) => {
                    if (event.code === 'Space') {
                        event.preventDefault();
                        startGame();
                    }
                    // T –¥–ª—è –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è debug —Ä–µ–∂–∏–º–∞
                    if (event.code === 'KeyT') {
                        debugMode = !debugMode;
                        debugElement.style.display = debugMode ? 'block' : 'none';
                        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º/—Å–∫—Ä—ã–≤–∞–µ–º –ª–∞–∑–µ—Ä–Ω—ã–µ —É–∫–∞–∑–∞—Ç–µ–ª–∏
                        if (sabers.left.laser) sabers.left.laser.visible = debugMode;
                        if (sabers.right.laser) sabers.right.laser.visible = debugMode;
                    }
                });
                
                // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ debug
                debugToggle.addEventListener('click', () => {
                    debugMode = !debugMode;
                    debugElement.style.display = debugMode ? 'block' : 'none';
                    debugToggle.textContent = debugMode ? 'Hide Debug' : 'Debug';
                    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º/—Å–∫—Ä—ã–≤–∞–µ–º –ª–∞–∑–µ—Ä–Ω—ã–µ —É–∫–∞–∑–∞—Ç–µ–ª–∏
                    if (sabers.left.laser) sabers.left.laser.visible = debugMode;
                    if (sabers.right.laser) sabers.right.laser.visible = debugMode;
                });
                
                messageElement.textContent = "–ì–æ—Ç–æ–≤–æ! –ù–∞–∂–º–∏—Ç–µ –°–¢–ê–†–¢ –ò–ì–†–´ –∏–ª–∏ –ü–†–û–ë–ï–õ –¥–ª—è –Ω–∞—á–∞–ª–∞";
                
            } catch (error) {
                console.error("Initialization error:", error);
                messageElement.textContent = "–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏: " + error.message;
            }
        }
        
        // –ó–∞–ø—É—Å–∫–∞–µ–º –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
