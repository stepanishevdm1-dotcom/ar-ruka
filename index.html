<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Beat Saber Web - –ó–∞–¥–Ω—è—è –∫–∞–º–µ—Ä–∞</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #000;
            color: white;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 2;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #score {
            font-size: 36px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
        }
        
        #combo {
            font-size: 24px;
            color: #ffaa00;
            margin-bottom: 20px;
        }
        
        #message {
            font-size: 18px;
            color: #888;
            margin-top: 10px;
        }
        
        #startButton {
            background: linear-gradient(45deg, #ff0080, #00ff88);
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 18px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 10px;
            transition: transform 0.2s;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
        }
        
        #startButton:hover {
            transform: scale(1.05);
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 25px;
            border-radius: 15px;
            text-align: center;
            z-index: 2;
            backdrop-filter: blur(10px);
            width: 90%;
            max-width: 500px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .hand-indicator {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin: 0 5px;
            vertical-align: middle;
        }
        
        #leftHandIndicator {
            background-color: #ff3366;
            box-shadow: 0 0 10px #ff3366;
        }
        
        #rightHandIndicator {
            background-color: #33ccff;
            box-shadow: 0 0 10px #33ccff;
        }
        
        #cameraStatus {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 12px 18px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
            z-index: 2;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #cameraIcon {
            font-size: 20px;
        }
        
        #cameraText {
            font-size: 14px;
        }
        
        #cameraPreview {
            position: absolute;
            bottom: 100px;
            right: 20px;
            width: 160px;
            height: 120px;
            border-radius: 10px;
            overflow: hidden;
            z-index: 2;
            background: #000;
            border: 2px solid rgba(255, 255, 255, 0.2);
            display: none; /* –°–∫—Ä—ã–≤–∞–µ–º –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é */
        }
        
        #cameraPreview video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* –ó–µ—Ä–∫–∞–ª–∏–º –¥–ª—è –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è */
        }
        
        #toggleCameraPreview {
            position: absolute;
            bottom: 80px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            z-index: 3;
            font-size: 12px;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: white;
            z-index: 10;
        }
        
        .hidden {
            display: none !important;
        }
        
        .camera-mirror {
            transform: scaleX(-1) !important;
        }
        
        #timeLeft {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 10px;
            z-index: 2;
            font-size: 24px;
            color: #00ff88;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(0, 255, 136, 0.3);
        }
        
        .arrow-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: rgba(255, 255, 255, 0.5);
            z-index: 1;
            pointer-events: none;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.7; }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>
    <div id="container">
        <div id="ui">
            <div id="score">0</div>
            <div id="combo">Combo: 0</div>
            <div id="message">–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–∞–º–µ—Ä—ã...</div>
            <button id="startButton">–°–¢–ê–†–¢ –ò–ì–†–´</button>
        </div>
        
        <div id="cameraStatus">
            <div id="cameraIcon">üì∑</div>
            <div id="cameraText">–ó–∞–¥–Ω—è—è –∫–∞–º–µ—Ä–∞</div>
        </div>
        
        <div id="timeLeft" class="hidden">90</div>
        
        <div id="instructions">
            <div style="margin-bottom: 10px; font-size: 16px;">
                <span class="hand-indicator" id="leftHandIndicator"></span> –õ–µ–≤–∞—è —Ä—É–∫–∞ = –∫—Ä–∞—Å–Ω—ã–µ –∫—É–±—ã
                <span style="margin: 0 15px">|</span>
                <span class="hand-indicator" id="rightHandIndicator"></span> –ü—Ä–∞–≤–∞—è —Ä—É–∫–∞ = —Å–∏–Ω–∏–µ –∫—É–±—ã
            </div>
            <div style="font-size: 14px; color: #aaa; margin-top: 5px;">
                –ö—É–±—ã –ª–µ—Ç—è—Ç <span style="color: #ffaa00;">–ù–ê –í–ê–°</span> –æ—Ç —ç–∫—Ä–∞–Ω–∞. –†–µ–∂—å—Ç–µ –∏—Ö —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–º–∏ —Ä—É–∫–∞–º–∏!
            </div>
        </div>
        
        <div id="cameraPreview">
            <video id="cameraVideo" autoplay playsinline></video>
        </div>
        
        <button id="toggleCameraPreview" class="hidden">üëÅÔ∏è –ü–æ–∫–∞–∑–∞—Ç—å –∫–∞–º–µ—Ä—É</button>
        
        <div class="arrow-indicator">‚Üë –ö—É–±—ã –ª–µ—Ç—è—Ç —Å—é–¥–∞ ‚Üë</div>
        
        <!-- –°–∫—Ä—ã—Ç—ã–π video —ç–ª–µ–º–µ–Ω—Ç –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–∞–º–µ—Ä—ã -->
        <video id="inputVideo" class="hidden" autoplay playsinline></video>
        
        <canvas id="gameCanvas"></canvas>
    </div>

    <script>
        // –û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã –∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let scene, camera, renderer;
        let hands;
        let gameStarted = false;
        let score = 0;
        let combo = 0;
        let maxCombo = 0;
        let missedCubes = 0;
        let cubes = [];
        let sabers = { left: null, right: null };
        let trails = { left: null, right: null };
        let lastCutTime = 0;
        let cubeSpawnInterval = null;
        let gameStartTime = 0;
        let timeLeft = 90;
        let timeInterval = null;
        let cameraPreviewVisible = false;
        let currentStream = null;
        
        // –≠–ª–µ–º–µ–Ω—Ç—ã DOM
        const scoreElement = document.getElementById('score');
        const comboElement = document.getElementById('combo');
        const messageElement = document.getElementById('message');
        const startButton = document.getElementById('startButton');
        const leftHandIndicator = document.getElementById('leftHandIndicator');
        const rightHandIndicator = document.getElementById('rightHandIndicator');
        const videoElement = document.getElementById('inputVideo');
        const cameraVideo = document.getElementById('cameraVideo');
        const cameraPreview = document.getElementById('cameraPreview');
        const toggleCameraPreview = document.getElementById('toggleCameraPreview');
        const timeLeftElement = document.getElementById('timeLeft');
        const cameraStatus = document.getElementById('cameraStatus');
        
        // –¶–≤–µ—Ç–∞
        const COLORS = {
            RED: 0xff3366,      // –õ–µ–≤–∞—è —Ä—É–∫–∞
            BLUE: 0x33ccff,     // –ü—Ä–∞–≤–∞—è —Ä—É–∫–∞
            SABER_LEFT: 0xff3366,
            SABER_RIGHT: 0x33ccff,
            TRAIL_LEFT: 0xff3366,
            TRAIL_RIGHT: 0x33ccff,
            BACKGROUND: 0x000011,
            LASER: 0xffffff,
            TUNNEL: 0x223366
        };
        
        // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∏–≥—Ä—ã - –ö–£–ë–´ –õ–ï–¢–Ø–¢ –ù–ê –ò–ì–†–û–ö–ê
        const GAME_CONFIG = {
            CUBE_SPAWN_RATE: 800, // –º—Å –º–µ–∂–¥—É —Å–ø–∞–≤–Ω–æ–º –∫—É–±–æ–≤
            CUBE_SPEED_MIN: 0.1,
            CUBE_SPEED_MAX: 0.15,
            CUBE_LANE_POSITIONS: [-1.5, -0.5, 0.5, 1.5], // –ü–æ–∑–∏—Ü–∏–∏ –¥–æ—Ä–æ–∂–µ–∫
            CUBE_START_Z: 15,      // –ö—É–±—ã –Ω–∞—á–∏–Ω–∞—é—Ç –î–ê–õ–ï–ö–û (–≤ –≥–ª—É–±–∏–Ω–µ —Å—Ü–µ–Ω—ã)
            CUBE_END_Z: 3,         // –ö—É–±—ã –∏—Å—á–µ–∑–∞—é—Ç –∑–¥–µ—Å—å (–ü–ï–†–ï–î –∏–≥—Ä–æ–∫–æ–º)
            SABER_LENGTH: 1.2,
            MISS_LIMIT: 15,
            GAME_DURATION: 90000, // 90 —Å–µ–∫—É–Ω–¥
            COMBO_TIMEOUT: 2000,
            PLAYER_Z_POSITION: 0   // –ò–≥—Ä–æ–∫ –≤ –Ω–∞—á–∞–ª–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
        };
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Three.js —Å—Ü–µ–Ω—ã
        function initThreeJS() {
            // –°–æ–∑–¥–∞–µ–º —Å—Ü–µ–Ω—É
            scene = new THREE.Scene();
            scene.background = new THREE.Color(COLORS.BACKGROUND);
            scene.fog = new THREE.Fog(COLORS.BACKGROUND, 10, 30);
            
            // –°–æ–∑–¥–∞–µ–º –∫–∞–º–µ—Ä—É –æ—Ç –ø–µ—Ä–≤–æ–≥–æ –ª–∏—Ü–∞
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1.6, GAME_CONFIG.PLAYER_Z_POSITION); // –í—ã—Å–æ—Ç–∞ –≥–ª–∞–∑
            camera.lookAt(0, 1.6, 10); // –°–º–æ—Ç—Ä–∏–º –í–ì–õ–£–ë–¨ —Å—Ü–µ–Ω—ã (–æ—Ç–∫—É–¥–∞ –ª–µ—Ç—è—Ç –∫—É–±—ã)
            
            // –°–æ–∑–¥–∞–µ–º —Ä–µ–Ω–¥–µ—Ä–µ—Ä
            const canvas = document.getElementById('gameCanvas');
            renderer = new THREE.WebGLRenderer({ 
                canvas, 
                antialias: true,
                alpha: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // –î–æ–±–∞–≤–ª—è–µ–º –æ—Å–≤–µ—â–µ–Ω–∏–µ
            const ambientLight = new THREE.AmbientLight(0x333344, 0.6);
            scene.add(ambientLight);
            
            // –û—Å–Ω–æ–≤–Ω–æ–π —Å–≤–µ—Ç —Å–ø–µ—Ä–µ–¥–∏ (–æ—Å–≤–µ—â–∞–µ—Ç –∫—É–±—ã, –ª–µ—Ç—è—â–∏–µ –Ω–∞ –∏–≥—Ä–æ–∫–∞)
            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mainLight.position.set(0, 3, 10);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            scene.add(mainLight);
            
            // –ó–∞–¥–Ω–∏–π —Å–≤–µ—Ç –¥–ª—è –ø–æ–¥—Å–≤–µ—Ç–∫–∏ —Å–∞–±–µ–ª—å
            const backLight = new THREE.DirectionalLight(0x4488ff, 0.4);
            backLight.position.set(0, 2, -5);
            scene.add(backLight);
            
            // –°–æ–∑–¥–∞–µ–º —Å–∞–±–ª–∏
            createSaber('left', COLORS.SABER_LEFT);
            createSaber('right', COLORS.SABER_RIGHT);
            
            // –°–æ–∑–¥–∞–µ–º —Å–ª–µ–¥—ã –æ—Ç —Å–∞–±–µ–ª—å
            createTrail('left', COLORS.TRAIL_LEFT);
            createTrail('right', COLORS.TRAIL_RIGHT);
            
            // –°–æ–∑–¥–∞–µ–º –∏–≥—Ä–æ–≤–æ–π —Ç—É–Ω–Ω–µ–ª—å (–∫—É–±—ã –ª–µ—Ç—è—Ç –ò–ó –ì–õ–£–ë–ò–ù–´)
            createGameTunnel();
            
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞
            window.addEventListener('resize', onWindowResize);
            
            messageElement.textContent = "–ó–∞–≥—Ä—É–∑–∫–∞ –¥–µ—Ç–µ–∫—Ç–æ—Ä–∞ —Ä—É–∫...";
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –∏–≥—Ä–æ–≤–æ–≥–æ —Ç—É–Ω–Ω–µ–ª—è (–∫—É–±—ã –ª–µ—Ç—è—Ç –ò–ó –ì–õ–£–ë–ò–ù–´ –Ω–∞ –∏–≥—Ä–æ–∫–∞)
        function createGameTunnel() {
            // –ü–æ–ª —Ç—É–Ω–Ω–µ–ª—è
            const floorGeometry = new THREE.PlaneGeometry(8, 40);
            const floorMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x111133,
                shininess: 20,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.8
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = Math.PI / 2;
            floor.position.y = -1;
            floor.position.z = 10; // –¶–µ–Ω—Ç—Ä —Ç—É–Ω–Ω–µ–ª—è
            floor.receiveShadow = true;
            scene.add(floor);
            
            // –ë–æ–∫–æ–≤—ã–µ —Å—Ç–µ–Ω–∫–∏ —Ç—É–Ω–Ω–µ–ª—è
            const wallMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x222244,
                transparent: true,
                opacity: 0.1,
                side: THREE.DoubleSide
            });
            
            const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(40, 4), wallMaterial);
            leftWall.position.x = -3;
            leftWall.position.z = 10;
            leftWall.rotation.y = Math.PI / 2;
            scene.add(leftWall);
            
            const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(40, 4), wallMaterial);
            rightWall.position.x = 3;
            rightWall.position.z = 10;
            rightWall.rotation.y = -Math.PI / 2;
            scene.add(rightWall);
            
            // –°–æ–∑–¥–∞–µ–º –Ω–∞–ø—Ä–∞–≤–ª—è—é—â–∏–µ –ª–∏–Ω–∏–∏ –¥–ª—è –¥–æ—Ä–æ–∂–µ–∫
            const lineMaterial = new THREE.LineBasicMaterial({
                color: 0x3366ff,
                transparent: true,
                opacity: 0.2,
                linewidth: 1
            });
            
            // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏ –¥–æ—Ä–æ–∂–µ–∫ (–ª–µ—Ç—è—Ç –∏–∑ –≥–ª—É–±–∏–Ω—ã)
            GAME_CONFIG.CUBE_LANE_POSITIONS.forEach(x => {
                const points = [];
                for (let z = GAME_CONFIG.CUBE_START_Z; z > GAME_CONFIG.CUBE_END_Z; z -= 2) {
                    points.push(new THREE.Vector3(x, 1.5, z));
                }
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, lineMaterial);
                scene.add(line);
            });
            
            // –°–æ–∑–¥–∞–µ–º —á–∞—Å—Ç–∏—Ü—ã –≤ –≥–ª—É–±–∏–Ω–µ —Ç—É–Ω–Ω–µ–ª—è (–∏—Å—Ç–æ—á–Ω–∏–∫ –∫—É–±–æ–≤)
            createTunnelParticles();
            
            // –î–æ–±–∞–≤–ª—è–µ–º "—Ñ–∏–Ω–∏—à–Ω—É—é —á–µ—Ä—Ç—É" –ø–µ—Ä–µ–¥ –∏–≥—Ä–æ–∫–æ–º
            const finishLineMaterial = new THREE.LineBasicMaterial({
                color: 0x00ff88,
                transparent: true,
                opacity: 0.3,
                linewidth: 2
            });
            
            const finishPoints = [
                new THREE.Vector3(-2, 1, GAME_CONFIG.CUBE_END_Z),
                new THREE.Vector3(2, 1, GAME_CONFIG.CUBE_END_Z)
            ];
            
            const finishGeometry = new THREE.BufferGeometry().setFromPoints(finishPoints);
            const finishLine = new THREE.Line(finishGeometry, finishLineMaterial);
            scene.add(finishLine);
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —á–∞—Å—Ç–∏—Ü –≤ —Ç—É–Ω–Ω–µ–ª–µ
        function createTunnelParticles() {
            const particleCount = 300;
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const colors = [];
            
            for (let i = 0; i < particleCount; i++) {
                // –ß–∞—Å—Ç–∏—Ü—ã –ª–µ—Ç—è—Ç –æ—Ç –≥–ª—É–±–∏–Ω—ã –∫ –∏–≥—Ä–æ–∫—É
                const x = (Math.random() - 0.5) * 6;
                const y = (Math.random() - 0.5) * 3 + 1;
                const z = Math.random() * 25 + 5; // –û—Ç 5 –¥–æ 30
                
                vertices.push(x, y, z);
                
                // –¶–≤–µ—Ç –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –ø–æ–∑–∏—Ü–∏–∏
                const color = new THREE.Color();
                color.setHSL(0.6, 0.8, 0.3 + Math.random() * 0.2);
                colors.push(color.r, color.g, color.b);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.05,
                vertexColors: true,
                transparent: true,
                opacity: 0.5
            });
            
            const particles = new THREE.Points(geometry, material);
            scene.add(particles);
            
            // –ê–Ω–∏–º–∞—Ü–∏—è —á–∞—Å—Ç–∏—Ü (–ª–µ—Ç—è—Ç –∫ –∏–≥—Ä–æ–∫—É)
            function animateParticles() {
                const positions = particles.geometry.attributes.position.array;
                
                for (let i = 0; i < particleCount * 3; i += 3) {
                    positions[i + 2] -= 0.05; // –î–≤–∏–∂–µ–Ω–∏–µ –∫ –∏–≥—Ä–æ–∫—É
                    
                    // –ï—Å–ª–∏ —á–∞—Å—Ç–∏—Ü–∞ –ø—Ä–æ—à–ª–∞ –∏–≥—Ä–æ–∫–∞, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –µ–µ –≤ –Ω–∞—á–∞–ª–æ
                    if (positions[i + 2] < 0) {
                        positions[i] = (Math.random() - 0.5) * 6;
                        positions[i + 1] = (Math.random() - 0.5) * 3 + 1;
                        positions[i + 2] = 25 + Math.random() * 5;
                    }
                }
                
                particles.geometry.attributes.position.needsUpdate = true;
                
                if (gameStarted) {
                    requestAnimationFrame(animateParticles);
                }
            }
            
            animateParticles();
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —Å–∞–±–ª–∏
        function createSaber(side, color) {
            const group = new THREE.Group();
            
            // –†—É–∫–æ—è—Ç—å —Å–∞–±–ª–∏
            const handleGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.3, 8);
            const handleMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x333333,
                emissive: 0x111111,
                emissiveIntensity: 0.3,
                shininess: 100
            });
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.position.y = 0.15;
            group.add(handle);
            
            // –õ–µ–∑–≤–∏–µ —Å–∞–±–ª–∏
            const bladeGeometry = new THREE.BoxGeometry(0.035, GAME_CONFIG.SABER_LENGTH, 0.035);
            const bladeMaterial = new THREE.MeshPhongMaterial({ 
                color: color,
                emissive: color,
                emissiveIntensity: 0.9,
                shininess: 100,
                transparent: true,
                opacity: 0.95
            });
            const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
            blade.position.y = GAME_CONFIG.SABER_LENGTH / 2 + 0.3;
            group.add(blade);
            
            // –°–≤–µ—á–µ–Ω–∏–µ –ª–µ–∑–≤–∏—è
            const glowGeometry = new THREE.CylinderGeometry(0.05, 0.05, GAME_CONFIG.SABER_LENGTH, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.2,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.y = GAME_CONFIG.SABER_LENGTH / 2 + 0.3;
            group.add(glow);
            
            scene.add(group);
            sabers[side] = {
                group: group,
                blade: blade,
                glow: glow,
                position: new THREE.Vector3(),
                velocity: new THREE.Vector3(),
                lastPosition: new THREE.Vector3(),
                isDetected: false,
                isCutting: false
            };
            
            // –ò–∑–Ω–∞—á–∞–ª—å–Ω–æ —Å–∫—Ä—ã–≤–∞–µ–º —Å–∞–±–ª–∏
            group.visible = false;
            group.position.z = GAME_CONFIG.PLAYER_Z_POSITION;
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —Å–ª–µ–¥–∞ –æ—Ç —Å–∞–±–ª–∏
        function createTrail(side, color) {
            const trailGeometry = new THREE.BufferGeometry();
            const trailMaterial = new THREE.LineBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.7,
                linewidth: 2
            });
            
            const trail = new THREE.Line(trailGeometry, trailMaterial);
            scene.add(trail);
            
            trails[side] = {
                line: trail,
                points: [],
                maxPoints: 20
            };
            
            trail.visible = false;
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –∫—É–±–∞, –∫–æ—Ç–æ—Ä—ã–π –ª–µ—Ç–∏—Ç –ù–ê –ò–ì–†–û–ö–ê
        function createCube() {
            // –°–ª—É—á–∞–π–Ω–æ –≤—ã–±–∏—Ä–∞–µ–º —Ü–≤–µ—Ç –∏ —Å—Ç–æ—Ä–æ–Ω—É
            const isLeft = Math.random() > 0.5;
            const color = isLeft ? COLORS.RED : COLORS.BLUE;
            const targetHand = isLeft ? 'left' : 'right';
            
            // –í—ã–±–∏—Ä–∞–µ–º –¥–æ—Ä–æ–∂–∫—É –¥–ª—è —ç—Ç–æ–≥–æ —Ç–∏–ø–∞ —Ä—É–∫–∏
            const lanePositions = isLeft 
                ? GAME_CONFIG.CUBE_LANE_POSITIONS.filter((_, i) => i < 2)
                : GAME_CONFIG.CUBE_LANE_POSITIONS.filter((_, i) => i >= 2);
            
            const lane = lanePositions[Math.floor(Math.random() * lanePositions.length)];
            
            const geometry = new THREE.BoxGeometry(0.7, 0.7, 0.7);
            const material = new THREE.MeshPhongMaterial({ 
                color: color,
                emissive: color,
                emissiveIntensity: 0.4,
                shininess: 100,
                transparent: true,
                opacity: 0.95
            });
            
            const cube = new THREE.Mesh(geometry, material);
            cube.castShadow = true;
            cube.receiveShadow = true;
            
            // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º –∫—É–± –í –ì–õ–£–ë–ò–ù–ï —Å—Ü–µ–Ω—ã
            cube.position.x = lane;
            cube.position.y = 1.5; // –ù–∞ —É—Ä–æ–≤–Ω–µ –≥—Ä—É–¥–∏
            cube.position.z = GAME_CONFIG.CUBE_START_Z; // –î–ê–õ–ï–ö–û –û–¢ –ò–ì–†–û–ö–ê
            
            // –î–æ–±–∞–≤–ª—è–µ–º —Å—Ç—Ä–µ–ª–∫—É –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è (—Å–º–æ—Ç—Ä–∏—Ç –ù–ê –ò–ì–†–û–ö–ê)
            const arrowGeometry = new THREE.ConeGeometry(0.2, 0.4, 4);
            const arrowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                emissive: 0xffffff,
                emissiveIntensity: 0.5
            });
            const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
            arrow.rotation.x = Math.PI; // –°–º–æ—Ç—Ä–∏—Ç –ù–ê –ò–ì–†–û–ö–ê
            arrow.position.z = -0.4; // –ù–∞ –ø–µ—Ä–µ–¥–Ω–µ–π –≥—Ä–∞–Ω–∏ –∫—É–±–∞
            cube.add(arrow);
            
            // –î–æ–±–∞–≤–ª—è–µ–º —Å–≤–µ—á–µ–Ω–∏–µ –≤–æ–∫—Ä—É–≥ –∫—É–±–∞
            const glowGeometry = new THREE.BoxGeometry(0.85, 0.85, 0.85);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.1,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            cube.add(glow);
            
            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∫—É–±–∞
            cube.userData = {
                targetHand: targetHand,
                color: color,
                speed: GAME_CONFIG.CUBE_SPEED_MIN + Math.random() * (GAME_CONFIG.CUBE_SPEED_MAX - GAME_CONFIG.CUBE_SPEED_MIN),
                direction: new THREE.Vector3(0, 0, -1), // –õ–µ—Ç–∏—Ç –ö –ò–ì–†–û–ö–£!
                spawnTime: Date.now(),
                isActive: true,
                lane: lane
            };
            
            scene.add(cube);
            cubes.push(cube);
            
            return cube;
        }
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∑–∞–¥–Ω–µ–π –∫–∞–º–µ—Ä—ã
        async function initCamera() {
            try {
                // –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –∫–∞–º–µ—Ä
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                
                // –ò—â–µ–º –∑–∞–¥–Ω—é—é –∫–∞–º–µ—Ä—É (–æ–±—ã—á–Ω–æ –æ–Ω–∞ –∏–º–µ–µ—Ç label —Å "back", "rear" –∏–ª–∏ "environment")
                let rearCamera = null;
                for (const device of videoDevices) {
                    if (device.label.toLowerCase().includes('back') || 
                        device.label.toLowerCase().includes('rear') ||
                        device.label.toLowerCase().includes('environment') ||
                        device.label.toLowerCase().includes('1') || // –ß–∞—Å—Ç–æ –∑–∞–¥–Ω—è—è –∫–∞–º–µ—Ä–∞ –∏–º–µ–µ—Ç –∏–Ω–¥–µ–∫—Å 1
                        device.label.toLowerCase().includes('2')) {
                        rearCamera = device;
                        break;
                    }
                }
                
                // –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –∑–∞–¥–Ω—é—é, –±–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω—é—é –∫–∞–º–µ—Ä—É (—á–∞—Å—Ç–æ —ç—Ç–æ –∑–∞–¥–Ω—è—è)
                if (!rearCamera && videoDevices.length > 1) {
                    rearCamera = videoDevices[videoDevices.length - 1];
                }
                
                // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è –∫–∞–º–µ—Ä—ã
                const constraints = {
                    video: {
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        frameRate: { ideal: 30 },
                        facingMode: rearCamera ? { exact: rearCamera.deviceId } : 'environment'
                    },
                    audio: false
                };
                
                // –ü–æ–ª—É—á–∞–µ–º –ø–æ—Ç–æ–∫ —Å –∫–∞–º–µ—Ä—ã
                currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                
                // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –≤–∏–¥–µ–æ —ç–ª–µ–º–µ–Ω—Ç—ã
                videoElement.srcObject = currentStream;
                cameraVideo.srcObject = currentStream;
                
                // –ñ–¥–µ–º –∑–∞–≥—Ä—É–∑–∫–∏ –≤–∏–¥–µ–æ
                await new Promise(resolve => {
                    videoElement.onloadedmetadata = () => {
                        videoElement.play();
                        resolve();
                    };
                });
                
                await new Promise(resolve => {
                    cameraVideo.onloadedmetadata = () => {
                        cameraVideo.play();
                        resolve();
                    };
                });
                
                cameraStatus.querySelector('#cameraIcon').textContent = '‚úÖ';
                cameraStatus.querySelector('#cameraText').textContent = rearCamera ? '–ó–∞–¥–Ω—è—è –∫–∞–º–µ—Ä–∞' : '–ö–∞–º–µ—Ä–∞ –∞–∫—Ç–∏–≤–Ω–∞';
                cameraStatus.style.color = '#00ff88';
                
                messageElement.textContent = "–ö–∞–º–µ—Ä–∞ –∑–∞–ø—É—â–µ–Ω–∞! –ù–∞–∂–º–∏—Ç–µ –°–¢–ê–†–¢ –ò–ì–†–´";
                
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫—É –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞
                toggleCameraPreview.classList.remove('hidden');
                
                return true;
                
            } catch (error) {
                console.error("Camera error:", error);
                
                // –ü—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å –ª—é–±—É—é –∫–∞–º–µ—Ä—É –∫–∞–∫ –∑–∞–ø–∞—Å–Ω–æ–π –≤–∞—Ä–∏–∞–Ω—Ç
                try {
                    const constraints = {
                        video: {
                            width: { ideal: 640 },
                            height: { ideal: 480 },
                            frameRate: { ideal: 30 }
                        },
                        audio: false
                    };
                    
                    currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                    videoElement.srcObject = currentStream;
                    cameraVideo.srcObject = currentStream;
                    
                    await videoElement.play();
                    await cameraVideo.play();
                    
                    cameraStatus.querySelector('#cameraIcon').textContent = '‚ö†Ô∏è';
                    cameraStatus.querySelector('#cameraText').textContent = '–ö–∞–º–µ—Ä–∞ (–∞–≤—Ç–æ)';
                    cameraStatus.style.color = '#ffaa00';
                    
                    messageElement.textContent = "–ö–∞–º–µ—Ä–∞ –∑–∞–ø—É—â–µ–Ω–∞ (–∞–≤—Ç–æ —Ä–µ–∂–∏–º)! –ù–∞–∂–º–∏—Ç–µ –°–¢–ê–†–¢ –ò–ì–†–´";
                    toggleCameraPreview.classList.remove('hidden');
                    
                    return true;
                    
                } catch (fallbackError) {
                    console.error("Fallback camera error:", fallbackError);
                    cameraStatus.querySelector('#cameraIcon').textContent = '‚ùå';
                    cameraStatus.querySelector('#cameraText').textContent = '–ù–µ—Ç –∫–∞–º–µ—Ä—ã';
                    cameraStatus.style.color = '#ff3333';
                    
                    messageElement.textContent = "–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –∫–∞–º–µ—Ä–µ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è.";
                    return false;
                }
            }
        }
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –¥–µ—Ç–µ–∫—Ç–æ—Ä–∞ —Ä—É–∫
        async function initHandDetection() {
            hands = new self.Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });
            
            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7,
                selfieMode: false // –û–¢–ö–õ–Æ–ß–ê–ï–ú selfieMode –¥–ª—è –∑–∞–¥–Ω–µ–π –∫–∞–º–µ—Ä—ã
            });
            
            hands.onResults(onHandResults);
            
            // –ó–∞–ø—É—Å–∫–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É –∫–∞–¥—Ä–∞
            async function processFrame() {
                if (videoElement.readyState >= 2) {
                    await hands.send({ image: videoElement });
                }
                if (gameStarted) {
                    requestAnimationFrame(processFrame);
                }
            }
            
            // –ñ–¥–µ–º –Ω–µ–º–Ω–æ–≥–æ –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º –æ–±—Ä–∞–±–æ—Ç–∫–∏
            setTimeout(() => {
                if (videoElement.srcObject) {
                    processFrame();
                }
            }, 500);
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –¥–µ—Ç–µ–∫—Ü–∏–∏ —Ä—É–∫
        function onHandResults(results) {
            if (!gameStarted) return;
            
            // –°–±—Ä–æ—Å–∏—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è
            sabers.left.isDetected = false;
            sabers.right.isDetected = false;
            leftHandIndicator.style.backgroundColor = '#555';
            rightHandIndicator.style.backgroundColor = '#555';
            
            if (results.multiHandLandmarks && results.multiHandedness) {
                for (let i = 0; i < Math.min(results.multiHandLandmarks.length, 2); i++) {
                    const landmarks = results.multiHandLandmarks[i];
                    const handedness = results.multiHandedness[i].label; // "Left" –∏–ª–∏ "Right"
                    
                    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∑–∞–ø—è—Å—Ç—å–µ (landmark 0) –∏ —Å—Ä–µ–¥–Ω—é—é —Ç–æ—á–∫—É –ª–∞–¥–æ–Ω–∏
                    const wrist = landmarks[0];
                    const middleBase = landmarks[9];
                    
                    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã MediaPipe –≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã Three.js
                    // –í–∞–∂–Ω–æ: –¥–ª—è –∑–∞–¥–Ω–µ–π –∫–∞–º–µ—Ä—ã –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —É–∂–µ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ
                    
                    // X: —Å–ª–µ–≤–∞ –Ω–∞–ø—Ä–∞–≤–æ (-2 –¥–æ 2) - –ò–ù–í–ï–†–¢–ò–†–£–ï–ú –¥–ª—è –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
                    const x = -(wrist.x - 0.5) * 4;
                    
                    // Y: —Å–Ω–∏–∑—É –≤–≤–µ—Ä—Ö (0.5 –¥–æ 2.5)
                    const y = (1.0 - wrist.y) * 2 + 0.5;
                    
                    // Z: –≥–ª—É–±–∏–Ω–∞ (–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–∞—è - –±–ª–∏–∂–µ –∫ –∫–∞–º–µ—Ä–µ)
                    const z = GAME_CONFIG.PLAYER_Z_POSITION - (wrist.z * 2);
                    
                    const handKey = handedness.toLowerCase(); // "left" –∏–ª–∏ "right"
                    
                    if (sabers[handKey]) {
                        const saber = sabers[handKey];
                        const newPosition = new THREE.Vector3(x, y, z);
                        
                        // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å
                        if (saber.lastPosition.x !== 0 || saber.lastPosition.y !== 0 || saber.lastPosition.z !== 0) {
                            saber.velocity.subVectors(newPosition, saber.lastPosition);
                        }
                        saber.lastPosition.copy(saber.position);
                        saber.position.copy(newPosition);
                        
                        // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é —Å–∞–±–ª–∏
                        saber.group.position.copy(saber.position);
                        
                        // –í—Ä–∞—â–∞–µ–º —Å–∞–±–ª—é –≤ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ –¥–≤–∏–∂–µ–Ω–∏—è
                        if (saber.velocity.length() > 0.01) {
                            const targetPos = saber.position.clone().add(saber.velocity.normalize());
                            saber.group.lookAt(targetPos);
                        } else {
                            // –ë–∞–∑–æ–≤–∞—è –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏—è - –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ
                            saber.group.rotation.set(0, 0, 0);
                        }
                        
                        // –û–±–Ω–æ–≤–ª—è–µ–º —Å–ª–µ–¥
                        const trailPos = saber.position.clone();
                        trailPos.y += 0.3;
                        updateTrail(handKey, trailPos);
                        
                        saber.isDetected = true;
                        saber.group.visible = true;
                        
                        // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä
                        const indicator = handKey === 'left' ? leftHandIndicator : rightHandIndicator;
                        indicator.style.backgroundColor = handKey === 'left' ? '#ff3366' : '#33ccff';
                        indicator.style.boxShadow = `0 0 10px ${handKey === 'left' ? '#ff3366' : '#33ccff'}`;
                        
                        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–ª–∏–∑–∏–∏ —Å –∫—É–±–∞–º–∏
                        checkCollisions(handKey);
                    }
                }
            }
            
            // –°–∫—Ä—ã–≤–∞–µ–º –Ω–µ–æ–±–Ω–∞—Ä—É–∂–µ–Ω–Ω—ã–µ —Å–∞–±–ª–∏
            if (!sabers.left.isDetected) {
                sabers.left.group.visible = false;
                trails.left.line.visible = false;
            }
            if (!sabers.right.isDetected) {
                sabers.right.group.visible = false;
                trails.right.line.visible = false;
            }
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–ª–µ–¥–∞ —Å–∞–±–ª–∏
        function updateTrail(side, position) {
            const trail = trails[side];
            if (!trail || !sabers[side].isDetected) return;
            
            // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—É—é —Ç–æ—á–∫—É
            trail.points.unshift(position.clone());
            
            // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ—á–µ–∫
            if (trail.points.length > trail.maxPoints) {
                trail.points.pop();
            }
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –≥–µ–æ–º–µ—Ç—Ä–∏—é
            if (trail.points.length > 1) {
                const positions = new Float32Array(trail.points.length * 3);
                for (let i = 0; i < trail.points.length; i++) {
                    positions[i * 3] = trail.points[i].x;
                    positions[i * 3 + 1] = trail.points[i].y;
                    positions[i * 3 + 2] = trail.points[i].z;
                }
                
                trail.line.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                trail.line.geometry.attributes.position.needsUpdate = true;
                trail.line.visible = true;
            }
        }
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π —Å –∫—É–±–∞–º–∏
        function checkCollisions(handKey) {
            const saber = sabers[handKey];
            if (!saber || !saber.isDetected) return;
            
            // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ñ–µ—Ä—É –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–æ–ª–ª–∏–∑–∏–π
            const saberSphere = new THREE.Sphere(saber.position, 0.4);
            
            for (let i = cubes.length - 1; i >= 0; i--) {
                const cube = cubes[i];
                if (!cube.userData.isActive) continue;
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø–æ–¥—Ö–æ–¥—è—â–∞—è –ª–∏ —ç—Ç–æ —Ä—É–∫–∞ –¥–ª—è —ç—Ç–æ–≥–æ –∫—É–±–∞
                if (cube.userData.targetHand !== handKey) continue;
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ (–∫—É–± —É–∂–µ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –±–ª–∏–∑–∫–æ)
                const cubeSphere = new THREE.Sphere(cube.position, 0.5);
                
                if (saberSphere.intersectsSphere(cubeSphere)) {
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å —É–¥–∞—Ä–∞
                    const saberSpeed = saber.velocity.length();
                    
                    if (saberSpeed > 0.05) {
                        cutCube(cube, handKey, saberSpeed);
                        cubes.splice(i, 1);
                        saber.isCutting = true;
                        setTimeout(() => saber.isCutting = false, 100);
                    }
                }
            }
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–∞–∑—Ä–µ–∑–∞–Ω–∏—è –∫—É–±–∞
        function cutCube(cube, handKey, speed) {
            cube.userData.isActive = false;
            
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ç–∞–π–º–µ—Ä –∫–æ–º–±–æ
            lastCutTime = Date.now();
            
            // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –∫–æ–º–±–æ –∏ —Å—á–µ—Ç
            combo++;
            const points = Math.floor(10 * combo * Math.min(speed * 15, 2.5));
            score += points;
            
            if (combo > maxCombo) {
                maxCombo = combo;
            }
            
            // –û–±–Ω–æ–≤–ª—è–µ–º UI
            scoreElement.textContent = score;
            comboElement.textContent = `Combo: ${combo} (Max: ${maxCombo})`;
            comboElement.style.color = combo >= 10 ? '#ffaa00' : '#00ff88';
            
            // –í–∏–∑—É–∞–ª—å–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã
            createCubeExplosion(cube.position, cube.userData.color, speed);
            
            // –í–∏–±—Ä–∞—Ü–∏—è
            if (navigator.vibrate) {
                navigator.vibrate(30);
            }
            
            // –£–¥–∞–ª—è–µ–º –∫—É–±
            scene.remove(cube);
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –≤–∑—Ä—ã–≤–∞ –ø—Ä–∏ —Ä–∞–∑—Ä–µ–∑–∞–Ω–∏–∏ –∫—É–±–∞
        function createCubeExplosion(position, color, speed) {
            const particleCount = Math.floor(20 * speed);
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            
            for (let i = 0; i < particleCount; i++) {
                // –ß–∞—Å—Ç–∏—Ü—ã —Ä–∞–∑–ª–µ—Ç–∞—é—Ç—Å—è –æ—Ç —Ç–æ—á–∫–∏ —É–¥–∞—Ä–∞
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 0.5;
                const x = Math.cos(angle) * radius;
                const y = Math.random() * 0.5;
                const z = Math.sin(angle) * radius;
                vertices.push(x, y, z);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            
            const material = new THREE.PointsMaterial({
                color: color,
                size: 0.08,
                transparent: true,
                opacity: 0.9
            });
            
            const particles = new THREE.Points(geometry, material);
            particles.position.copy(position);
            scene.add(particles);
            
            // –ê–Ω–∏–º–∞—Ü–∏—è —á–∞—Å—Ç–∏—Ü
            const particleData = [];
            for (let i = 0; i < particleCount; i++) {
                particleData.push({
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.4,
                        (Math.random() - 0.5) * 0.4,
                        (Math.random() - 0.5) * 0.4
                    ),
                    life: 1.0
                });
            }
            
            function animateParticles() {
                let allDead = true;
                const positions = particles.geometry.attributes.position.array;
                
                for (let i = 0; i < particleCount; i++) {
                    const data = particleData[i];
                    if (data.life > 0) {
                        allDead = false;
                        data.life -= 0.04;
                        
                        positions[i * 3] += data.velocity.x;
                        positions[i * 3 + 1] += data.velocity.y;
                        positions[i * 3 + 2] += data.velocity.z;
                        
                        data.velocity.y -= 0.015; // –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏—è
                    }
                }
                
                particles.geometry.attributes.position.needsUpdate = true;
                material.opacity -= 0.04;
                material.size -= 0.002;
                
                if (allDead || material.opacity <= 0) {
                    scene.remove(particles);
                    return;
                }
                
                requestAnimationFrame(animateParticles);
            }
            
            animateParticles();
        }
        
        // –ó–∞–ø—É—Å–∫ –∏–≥—Ä—ã
        function startGame() {
            if (gameStarted) {
                stopGame();
                return;
            }
            
            gameStarted = true;
            gameStartTime = Date.now();
            score = 0;
            combo = 0;
            maxCombo = 0;
            missedCubes = 0;
            timeLeft = 90;
            
            // –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ –∫—É–±—ã
            cubes.forEach(cube => scene.remove(cube));
            cubes = [];
            
            // –û–±–Ω–æ–≤–ª—è–µ–º UI
            scoreElement.textContent = "0";
            comboElement.textContent = "Combo: 0 (Max: 0)";
            comboElement.style.color = '#00ff88';
            messageElement.textContent = "–ò–≥—Ä–∞ –Ω–∞—á–∞–ª–∞—Å—å! –†–µ–∂—å—Ç–µ –∫—É–±—ã!";
            startButton.textContent = "–û–°–¢–ê–ù–û–í–ò–¢–¨ –ò–ì–†–£";
            timeLeftElement.textContent = timeLeft;
            timeLeftElement.classList.remove('hidden');
            
            // –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–∞–π–º–µ—Ä
            if (timeInterval) clearInterval(timeInterval);
            timeInterval = setInterval(() => {
                if (gameStarted) {
                    timeLeft--;
                    timeLeftElement.textContent = timeLeft;
                    
                    if (timeLeft <= 10) {
                        timeLeftElement.style.color = '#ff3366';
                        timeLeftElement.style.animation = 'pulse 0.5s infinite';
                    }
                    
                    if (timeLeft <= 0) {
                        stopGame();
                    }
                }
            }, 1000);
            
            // –ó–∞–ø—É—Å–∫–∞–µ–º —Å–ø–∞–≤–Ω –∫—É–±–æ–≤
            if (cubeSpawnInterval) clearInterval(cubeSpawnInterval);
            cubeSpawnInterval = setInterval(() => {
                if (gameStarted) {
                    createCube();
                    
                    // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å–ª–æ–∂–Ω–æ—Å—Ç—å —Å–æ –≤—Ä–µ–º–µ–Ω–µ–º
                    const elapsed = Date.now() - gameStartTime;
                    if (elapsed > 30000 && Math.random() > 0.6) {
                        createCube();
                    }
                    if (elapsed > 60000 && Math.random() > 0.4) {
                        createCube();
                    }
                }
            }, GAME_CONFIG.CUBE_SPAWN_RATE);
            
            // –°–∫—Ä—ã–≤–∞–µ–º —Å—Ç—Ä–µ–ª–∫—É-–∏–Ω–¥–∏–∫–∞—Ç–æ—Ä
            document.querySelector('.arrow-indicator').style.display = 'none';
        }
        
        // –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –∏–≥—Ä—ã
        function stopGame() {
            gameStarted = false;
            
            if (cubeSpawnInterval) {
                clearInterval(cubeSpawnInterval);
                cubeSpawnInterval = null;
            }
            
            if (timeInterval) {
                clearInterval(timeInterval);
                timeInterval = null;
            }
            
            const elapsed = Math.floor((Date.now() - gameStartTime) / 1000);
            messageElement.textContent = `–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞! –í—Ä–µ–º—è: ${elapsed}—Å, –°—á–µ—Ç: ${score}, –ú–∞–∫—Å. –∫–æ–º–±–æ: ${maxCombo}`;
            startButton.textContent = "–ù–û–í–ê–Ø –ò–ì–†–ê";
            timeLeftElement.classList.add('hidden');
            timeLeftElement.style.color = '#00ff88';
            timeLeftElement.style.animation = '';
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å—Ç—Ä–µ–ª–∫—É-–∏–Ω–¥–∏–∫–∞—Ç–æ—Ä
            document.querySelector('.arrow-indicator').style.display = 'block';
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–≥—Ä–æ–≤–æ–π –ª–æ–≥–∏–∫–∏
        function updateGame() {
            if (!gameStarted) return;
            
            const currentTime = Date.now();
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –∫—É–±—ã (–ª–µ—Ç—è—Ç –ö –ò–ì–†–û–ö–£)
            for (let i = cubes.length - 1; i >= 0; i--) {
                const cube = cubes[i];
                
                // –î–≤–∏–≥–∞–µ–º –∫—É–± –ö –ò–ì–†–û–ö–£ (z —É–º–µ–Ω—å—à–∞–µ—Ç—Å—è)
                cube.position.add(cube.userData.direction.clone().multiplyScalar(cube.userData.speed));
                
                // –í—Ä–∞—â–∞–µ–º –∫—É–±
                cube.rotation.x += 0.015;
                cube.rotation.y += 0.015;
                
                // –ú–µ—Ä—Ü–∞–Ω–∏–µ —Å–≤–µ—á–µ–Ω–∏—è
                const glow = cube.children.find(child => child.material && child.material.opacity === 0.1);
                if (glow) {
                    glow.material.opacity = 0.1 + Math.sin(currentTime * 0.005) * 0.05;
                }
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –ø—Ä–æ—à–µ–ª –ª–∏ –∫—É–± –∏–≥—Ä–æ–∫–∞
                if (cube.position.z < GAME_CONFIG.CUBE_END_Z) {
                    cube.userData.isActive = false;
                    scene.remove(cube);
                    cubes.splice(i, 1);
                    
                    missedCubes++;
                    combo = 0;
                    comboElement.textContent = `Combo: 0 (Max: ${maxCombo})`;
                    comboElement.style.color = '#00ff88';
                    
                    if (missedCubes >= GAME_CONFIG.MISS_LIMIT) {
                        messageElement.textContent = "–°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –ø—Ä–æ–ø—É—â–µ–Ω–æ! –ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞.";
                        stopGame();
                    }
                }
            }
            
            // –¢–∞–π–º–∞—É—Ç –∫–æ–º–±–æ
            if (currentTime - lastCutTime > GAME_CONFIG.COMBO_TIMEOUT && combo > 0) {
                combo = 0;
                comboElement.textContent = `Combo: 0 (Max: ${maxCombo})`;
                comboElement.style.color = '#00ff88';
            }
        }
        
        // –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∫–∞–º–µ—Ä—ã
        function toggleCameraPreviewView() {
            cameraPreviewVisible = !cameraPreviewVisible;
            if (cameraPreviewVisible) {
                cameraPreview.style.display = 'block';
                toggleCameraPreview.textContent = 'üëÅÔ∏è –°–∫—Ä—ã—Ç—å –∫–∞–º–µ—Ä—É';
            } else {
                cameraPreview.style.display = 'none';
                toggleCameraPreview.textContent = 'üëÅÔ∏è –ü–æ–∫–∞–∑–∞—Ç—å –∫–∞–º–µ—Ä—É';
            }
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // –ê–Ω–∏–º–∞—Ü–∏–æ–Ω–Ω—ã–π —Ü–∏–∫–ª
        function animate() {
            requestAnimationFrame(animate);
            updateGame();
            renderer.render(scene, camera);
        }
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        async function init() {
            try {
                // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º Three.js
                initThreeJS();
                
                // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∫–∞–º–µ—Ä—É
                const cameraSuccess = await initCamera();
                
                if (cameraSuccess) {
                    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –¥–µ—Ç–µ–∫—Ç–æ—Ä —Ä—É–∫
                    await initHandDetection();
                    
                    // –ó–∞–ø—É—Å–∫–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏–æ–Ω–Ω—ã–π —Ü–∏–∫–ª
                    animate();
                    
                    messageElement.textContent = "–ì–æ—Ç–æ–≤–æ! –ù–∞–∂–º–∏—Ç–µ –°–¢–ê–†–¢ –ò–ì–†–´ –∏–ª–∏ –ü–†–û–ë–ï–õ";
                } else {
                    messageElement.textContent = "–¢—Ä–µ–±—É–µ—Ç—Å—è –∫–∞–º–µ—Ä–∞ –¥–ª—è –∏–≥—Ä—ã!";
                    startButton.disabled = true;
                }
                
                // –ù–∞–∑–Ω–∞—á–∞–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
                startButton.addEventListener('click', startGame);
                toggleCameraPreview.addEventListener('click', toggleCameraPreviewView);
                
                document.addEventListener('keydown', (event) => {
                    if (event.code === 'Space') {
                        event.preventDefault();
                        startGame();
                    }
                    if (event.code === 'KeyC') {
                        toggleCameraPreviewView();
                    }
                });
                
            } catch (error) {
                console.error("Initialization error:", error);
                messageElement.textContent = "–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏: " + error.message;
            }
        }
        
        // –û—á–∏—Å—Ç–∫–∞ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏
        window.addEventListener('beforeunload', () => {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
            }
        });
        
        // –ó–∞–ø—É—Å–∫–∞–µ–º –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
